{"meta":{"title":"永远晴天的博客","subtitle":"面朝大海，春暖花开","description":"description","author":"Caspar Tan","url":"https://github.com/casparthh/casparthh.github.io"},"pages":[{"title":"About me","date":"2020-02-10T13:29:44.000Z","updated":"2020-02-22T14:43:29.662Z","comments":true,"path":"about/index.html","permalink":"https://github.com/casparthh/casparthh.github.io/about/index.html","excerpt":"","text":"个人介绍还没想好和大家说什么^_^ 联系方式QQ : 591926730Email : tanhuanghui@sina.com"}],"posts":[{"title":"JVM - Class文件格式","slug":"classfile","date":"2020-02-22T08:30:57.000Z","updated":"2020-02-23T08:38:35.805Z","comments":true,"path":"2020/02/22/classfile/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/22/classfile/","excerpt":"JVM 是一种规范参考文档：https://docs.oracle.com/en/java/javase/13/https://docs.oracle.com/javase/specs/index.htmlhttps://docs.oracle.com/javase/specs/jvms/se13/html/index.html 虚构出来的一台计算机 -字节码指令集（汇编语言）-内存管理：堆、栈、方法区等 JDK, JRE, JVM","text":"JVM 是一种规范参考文档：https://docs.oracle.com/en/java/javase/13/https://docs.oracle.com/javase/specs/index.htmlhttps://docs.oracle.com/javase/specs/jvms/se13/html/index.html 虚构出来的一台计算机 -字节码指令集（汇编语言）-内存管理：堆、栈、方法区等 JDK, JRE, JVM 常见的JVM实现 Hotspot - Oracl 官方 Jrockit - BEA，曾经号称世界上最快的JVM,被Oracle收购后，合并于hotspot J9 - IBM Microsoft VM TaobaoVM - Hotspot 深度定制版 LiquidVM - 直接针对硬件 azul zing - 商业版，最新垃圾回收的业界标杆，参考zing的垃圾回收产生了ZGC Class 文件查看ByteCode的方法 javap JBE 可以直接修改 JClassLib IDEA插件之一 Class 文件构成 魔数 “cafebaby” Class 文件版本 常量池 访问标志 类索引，父类索引，接口索引集合 字段表集合 方法表集合 属性表集合 Class 文件格式 类型 名称 数量 U4 magic 1 U2 minor_version 1 U2 major_version 1 U2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 U2 access_flags 1 U2 this_class 1 U2 super_class 1 U2 interfaces_count 1 U2 interfaces interfaces_count U2 fields_count 1 field_info fields fields_count U2 methods_count 1 method_info methods methods_count U2 attributes_count 1 attribute_info attributes attributes_count u1 一个字节，u2 两个字节。。。 一个16进制数就是4位，2个16进制数就是8位，也就是一个字节 char 1 个字节 int &amp; float 4个字节 double &amp; long 8个字节magic = 0xCAFEBABE.minor_version, major_version 定义版本号constant_pool_count = constant_pool.size +1 access_flags参考 jvms13 Table 4.1-B. Class access and property modifiers Flag Name Value Interpretation ACC_PUBLIC 0x0001 Declared public; may be accessed from outside its package. ACC_FINAL 0x0010 Declared final; no subclasses allowed. ACC_SUPER 0x0020 Treat superclass methods specially when invoked by the invokespecial instruction. ACC_INTERFACE 0x0200 Is an interface, not a class. ACC_ABSTRACT 0x0400 Declared abstract; must not be instantiated. ACC_SYNTHETIC 0x1000 Declared synthetic; not present in the source code. ACC_ANNOTATION 0x2000 Declared as an annotation type. ACC_ENUM 0x4000 Declared as an enum type. ACC_MODULE 0x8000 Is a module, not a class or interface. *实际值采用的位运算 Field Descriptors参考 jvms13 Table 4.3-A. Interpretation of field descriptors FieldType term Type Interpretation B byte signed byte C char Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 D double double-precision floating-point value F float single-precision floating-point value I int integer J long long integer L ClassName; reference an instance of class ClassName S short signed short Z boolean true or false [ reference one array dimension Method Descriptors( {ParameterDescriptor} ) ReturnDescriptor Object m(int i, double d, Thread t) {...} int-&gt;I, double-&gt;D, Thread-&gt;Ljava/lang/Thread，返回值Ojbect-&gt;Ljava/lang/Object; 所以该方法的描述符为： (IDLjava/lang/Thread;)Ljava/lang/Object; 如果返回值为空，则ReturnDescriptor为VoidDescriptor-&gt;V The character V indicates that the method returns no value (its result is void).Constant Pool常量池中的每一个entry必须是由一个字节的tag开始来表示该常量的种类。参考 jvms13 Table 4.4-A. Constant pool tags (by section) Constant Kind Tag Section CONSTANT_Utf8 1 §4.4.7 CONSTANT_Integer 3 §4.4.4 CONSTANT_Float 4 §4.4.4 CONSTANT_Long 5 §4.4.5 CONSTANT_Double 6 §4.4.5 CONSTANT_Class 7 §4.4.1 CONSTANT_String 8 §4.4.3 CONSTANT_Fieldref 9 §4.4.2 CONSTANT_Methodref 10 §4.4.2 CONSTANT_InterfaceMethodref 11 §4.4.2 CONSTANT_NameAndType 12 §4.4.6 CONSTANT_MethodHandle 15 §4.4.8 CONSTANT_MethodType 16 §4.4.9 CONSTANT_Dynamic (JDK11) 17 §4.4.10 CONSTANT_InvokeDynamic 18 §4.4.10 CONSTANT_Module (JDK9) 19 §4.4.11 CONSTANT_Package (JDK9) 20 §4.4.12 表中的section表是该tag详细文档对应的章节。 CONSTANT_Utf8_info12345CONSTANT_Utf8_info &#123; u1 tag; &#x2F;&#x2F;占一个字节, CONSTANT_Utf8 对就上面的值为1 u2 length; &#x2F;&#x2F;UTF-8字符串占用的字节数 u1 bytes[length]; &#x2F;&#x2F;长度为length的字符串&#125; CONSTANT_Integer_info, CONSTANT_Float_info Structures 数据结构123456789CONSTANT_Integer_info &#123; u1 tag; u4 bytes; &#125;CONSTANT_Float_info &#123; u1 tag; u4 bytes; &#125; CONSTANT_Long_info and CONSTANT_Double_info 数据结构12345678910CONSTANT_Long_info &#123; u1 tag; u4 high_bytes; u4 low_bytes;&#125;CONSTANT_Double_info &#123; u1 tag; u4 high_bytes; u4 low_bytes;&#125; CONSTANT_Class_info 数据结构1234CONSTANT_Class_info &#123; u1 tag; &#x2F;&#x2F;CONSTANT_Class 对应上面表中的7， 占一个字节； u2 name_index; &#x2F;&#x2F;指向常量池的索引位置，该位置存放类的名称, 占用2个字节&#125; CONSTANT_String_info 数据结构1234CONSTANT_String_info &#123; u1 tag; u2 string_index; &#x2F;&#x2F;占2字节，指向字符串的索引;&#125; CONSTANT_Fieldref_info, CONSTANT_Methodref_info, CONSTANT_InterfaceMethodref_info 内存节构123456789101112131415CONSTANT_Fieldref_info &#123; u1 tag; &#x2F;&#x2F;CONSTANT_Fieldref 对应上面表中的9， 占一个字节； u2 class_index; &#x2F;&#x2F;占2字节，指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项 u2 name_and_type_index; &#x2F;&#x2F;占2字节，指向字段描述符CONSTANT_NameAndType的索引项&#125;CONSTANT_Methodref_info &#123; u1 tag; &#x2F;&#x2F;CONSTANT_Methodref 对应上面表中的10， 占一个字节； u2 class_index; &#x2F;&#x2F;占2字节，指向声明方法的类或者接口描述符CONSTANT_Class_info的索引项 u2 name_and_type_index; &#x2F;&#x2F;占2字节，指向字段描述符CONSTANT_NameAndType的索引项&#125;CONSTANT_InterfaceMethodref_info &#123; u1 tag; &#x2F;&#x2F;CONSTANT_InterfaceMethodref 对应上面表中的11， 占一个字节； u2 class_index; &#x2F;&#x2F;占2字节，指向声明方法的类或者接口描述符CONSTANT_Class_info的索引项 u2 name_and_type_index; &#x2F;&#x2F;占2字节，指向字段描述符CONSTANT_NameAndType的索引项&#125; CONSTANT_NameAndType_info12345CONSTANT_NameAndType_info &#123; u1 tag; &#x2F;&#x2F;1字节，NameAndType 对就表中的值12 u2 name_index; &#x2F;&#x2F;2字节，指向该字段或方法名称常量项的索引 u2 descriptor_index; &#x2F;&#x2F;2字节，指向该字段或方法描述符常量项的索引&#125;","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://github.com/casparthh/casparthh.github.io/tags/JVM/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"JVM - GC和GC Tuning","slug":"GC","date":"2020-02-22T08:20:37.000Z","updated":"2020-02-23T08:38:35.796Z","comments":true,"path":"2020/02/22/GC/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/22/GC/","excerpt":"一、GC的基础知识什么是垃圾没有任何引用指向的一个对象或者多个对象（循环引用） 如何定位垃圾 引用计数（ReferenceCount） 根可达算法(RootSearching) 常见的垃圾回收算法 标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描） 拷贝算法 (copying) - 没有碎片，浪费空间 标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整）","text":"一、GC的基础知识什么是垃圾没有任何引用指向的一个对象或者多个对象（循环引用） 如何定位垃圾 引用计数（ReferenceCount） 根可达算法(RootSearching) 常见的垃圾回收算法 标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描） 拷贝算法 (copying) - 没有碎片，浪费空间 标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整） JVM内存分代模型（用于分代垃圾回收算法） 部分垃圾回收器使用的模型除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型G1是逻辑分代，物理不分代除此之外不仅逻辑分代，而且物理分代 新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace 永久代 元数据 - Class 永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存） 字符串常量 1.7 - 永久代，1.8 - 堆 MethodArea逻辑概念 - 永久代、元数据 新生代 = Eden + 2个suvivor区 YGC回收之后，大多数的对象会被回收，活着的进入s0 再次YGC，活着的对象eden + s0 -&gt; s1 再次YGC，eden + s1 -&gt; s0 年龄足够 -&gt; 老年代 （-XX:MaxTenuringThreshold=X X默认是15） s区装不下 -&gt; 老年代 老年代 顽固分子 老年代满了FGC Full GC 内存分配担保，在JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，然后新生代腾出来的空间用于为分配给最新的对象。 GC Tuning (Generation) 尽量减少FGC MinorGC = YGC MajorGC = FGC 二、垃圾回收器及调优常见的垃圾回收器 JDK诞生 Serial追随，为提高效率，诞生了PS，为了配合CMS，诞生了PN，CMS是1.4版本后期引入，CMS是里程碑式的GC，它开启了并发回收的过程，并发垃圾回收是因为无法忍受STW。 Serial：适用年轻代，串行回收 PS(Parallel Scavenge) 适用年轻代，并行回收 ParNew 适用年轻代，配合CMS的并行回收 SerialOld 适用老年代 ParallelOld 适用老年代，配合PS使用 CMS(ConcurrentMarkSweep) 老年代,并发的，垃圾回收和应用程序同时运行，降低STW(Stop The World)的时间(200ms)CMS问题比较多，所以现在没有一个版本默认是CMS，只能手工指定CMS既然是MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS的老年代分配对象分配不下的时候，使用SerialOld 进行老年代回收算法：三色标记 + Incremental Update工作过程：初始标记，并发标记，重新标记，并发清理优点：并发收集，低停顿缺点：占用大量的CPU，无法处理浮动垃圾，出现Concurrent Mode Failure，空间碎片 G1(10ms)算法：三色标记 + SATB (snapshot-at-the-beginning)优势：并行与并发，分代收集，空间整合，可预测的停顿步骤：初使标记，并发标记，最终标记，筛选回收 ZGC (1ms)算法：ColoredPointers + LoadBarrier Shenandoah算法：ColoredPointers + WriteBarrier PS 和 PN区别的延伸阅读：▪https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html 垃圾收集器跟内存大小的关系 Serial 几十兆 PS 上百兆 - 几个G CMS - 20G G1 - 上百G ZGC - 4T - 16T（JDK13） 1.8默认的垃圾回收：PS + ParallelOld 常见垃圾回收器组合参数设定：(1.8) -XX:+UseSerialGC = Serial New (DefNew) + Serial Old 小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器 -XX:+UseParNewGC = ParNew + SerialOld 这个组合已经很少用（在某些版本中已经废弃） -XX:+UseConcurrentMarkSweepGC = ParNew + CMS + Serial Old -XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】 -XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old -XX:+UseG1GC = G1 JVM调优第一步，了解JVM常用命令行参数 JVM的命令行参数参考：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html HotSpot参数分类 标准： - 开头，所有的HotSpot都支持 非标准：-X 开头，特定版本HotSpot支持特定命令 不稳定：-XX 开头，下个版本可能取消 java -X 区分概念：内存泄漏memory leak，内存溢出out of memory java -XX:+PrintCommandLineFlags -version 观查虚拟机配置 java -XX:+PrintFlagsInitial 默认参数值 java -XX:+PrintFlagsFinal 最终参数值 java -XX:+PrintFlagsFinal | grep xxx 找到对应的参数 java -XX:+PrintFlagsFinal -version |grep GC 调优前的基础概念： 吞吐量：吞吐量（CPU用于运行用户代码的时间与CPU消耗的总时间的比值）用户代码时间 /（用户代码执行时间 + 垃圾回收时间） 响应时间：STW越短，响应时间越好 所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量… 问题：科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO）响应时间：网站 GUI API （1.8 G1） 什么是调优？ 根据需求进行JVM规划和预调优 优化运行JVM运行环境（慢，卡顿） 解决JVM运行过程中出现的各种问题(OOM) 调优，从规划开始 调优，从业务场景开始，没有业务场景的调优都是耍流氓 无监控（压力测试，能看到结果），不调优 步骤： 熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器） 响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应） 吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS] 选择回收器组合 计算内存需求（经验值） 选定CPU（越高越好） 设定年代大小、升级年龄 设定日志参数 -Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause 或者每天产生一个日志文件 观察日志情况 解决JVM运行中的问题 top命令观察问题：内存 &amp; CPU 占用率。 top -Hp 观察进程中的线程，哪个线程CPU和内存占比高 jps(java process status) 参数 -mlv 定位具体java进程jstack 定位线程状况，重点关注：WAITING BLOCKEDeg.waiting on &lt;0x0000000088ca3310&gt; (a java.lang.Object)假如有一个进程中100个线程，很多线程都在waiting on ，一定要找到是哪个线程持有这把锁怎么找？搜索jstack dump的信息，找 ，看哪个线程持有这把锁RUNNABLE 为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称怎么样自定义线程池里的线程名称？（自定义ThreadFactory） jinfo pidjinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。 jstat -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler（最好用）jstat -gc|gcnew|gcold|gcutil 500 10 : 每个500个毫秒打印GC的情况，共打印10次退出jstat -class 观察加载类的数量jstat -options 查看所有options jmap 一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。jmap -heap -heap 打印heap的概要信息，GC使用的算法，heap（堆）的配置及JVM堆内存的使用情况.jmap - histo 4655 | head -20，查找有多少对象产生jmap -dump:format=b,file=xxx pid -dump 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件 线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿，线上慎用（电商不适合用） 1：-XX:+HeapDumpOnOutOfMemoryError 设定了参数HeapDump，OOM的时候会自动产生堆转储文件 2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响 3：用在线定位 使用MAT / jhat /jvisualvm 进行dump文件分析 Jhat参考资料：https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html Arthas在线排查工具 为什么需要在线排查？ 在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。 观察jvm信息 thread定位线程问题 dashboard 观察系统情况 heapdump + jhat分析 jad反编译 动态代理生成类的问题定位 第三方的类（观察代码） 版本问题（确定自己最新提交的版本是不是被使用） redefine 热替换 目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性 sc - search class watch - watch method 没有包含的功能：jmap 三、常用参数GC算法的基础概念 Card Table由于做YGC时，需要扫描整个OLD区，效率非常低，所以JVM设计了CardTable， 如果一个OLD区CardTable中有对象指向Y区，就将它设为Dirty，下次扫描时，只需要扫描Dirty Card在结构上，Card Table用BitMap来实现 GC常用参数 -Xmn -Xms -Xmx -Xss年轻代 最小堆 最大堆 栈空间 -XX:+UseTLAB使用TLAB(Thread Local Allocation Buffer)，默认打开 -XX:+PrintTLAB打印TLAB的使用情况 -XX:TLABSize设置TLAB大小 -XX:+DisableExplictGCSystem.gc()不管用 ，FGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationConcurrentTime (低) 打印应用程序时间 -XX:+PrintGCApplicationStoppedTime （低） 打印暂停时长 -XX:+PrintReferenceGC （重要性低）记录回收了多少种不同引用类型的引用 -verbose:class 类加载详细过程 -XX:+PrintVMOptions -XX:+PrintFlagsFinal -XX:+PrintFlagsInitial 必须会用 -Xloggc:/opt/log/gc.log -XX:MaxTenuringThreshold 升代年龄，最大值15 -XX:PretenureSizeThreshold=1M //大对象直接存入老年代,默认值是0，意思是不管多大都是先在eden中分配内存 锁自旋次数 -XX:PreBlockSpin 热点代码检测参数-XX:CompileThreshold 逃逸分析 标量替换 这些不建议设置 Parallel常用参数 -XX:SurvivorRatio -XX:+ParallelGCThreads 并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同 -XX:+UseAdaptiveSizePolicy 自动选择各区大小比例 CMS常用参数 -XX:+UseConcMarkSweepGC -XX:ParallelCMSThreads CMS线程数量 -XX:CMSInitiatingOccupancyFraction使用多少比例的老年代后开始CMS收集，默认是68%(近似值)，如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收） -XX:+UseCMSCompactAtFullCollection在FGC时进行压缩 -XX:CMSFullGCsBeforeCompaction多少次FGC之后进行压缩 -XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingPermOccupancyFraction达到什么比例时进行Perm回收 GCTimeRatio设置GC时间占用程序运行时间的百分比 -XX:MaxGCPauseMillis停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代 -XX:LargePageSizeInBytes=64m 内存分页 G1常用参数 -XX:+UseG1GC -XX:MaxGCPauseMillis建议值，G1会尝试调整Young区的块数来达到这个值 -XX:GCPauseIntervalMillis设置停顿间隔时间 -XX:+G1HeapRegionSize分区大小，建议逐渐增大该值，1 2 4 8 16 32。随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长ZGC做了改进（动态区块大小） G1NewSizePercent新生代最小比例，默认为5% G1MaxNewSizePercent新生代最大比例，默认为60% GCTimeRatioGC时间建议比例，G1会根据这个值调整堆空间 ConcGCThreads线程数量 InitiatingHeapOccupancyPercent启动G1的堆空间占用比例 四、参考资料 https://docs.oracle.com/en/java/javase/13/ https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp JVM调优参考文档：https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184 https://www.oracle.com/technical-resources/articles/java/g1gc.html Arthas：https://github.com/alibaba/arthas 启动arthas java -jar arthas-boot.jar 绑定java进程 dashboard命令观察系统整体情况 help 查看帮助 help xx 查看具体命令帮助","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://github.com/casparthh/casparthh.github.io/tags/JVM/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"JVM - JMM内存模型","slug":"jmm","date":"2020-02-22T08:20:37.000Z","updated":"2020-02-23T08:38:35.808Z","comments":true,"path":"2020/02/22/jmm/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/22/jmm/","excerpt":"一、CPU和内存的交互在计算机中，CPU和内存的交互最为频繁，相比内存，磁盘读写太慢，内存相当于高速的缓冲区。 在多核CPU中，每个处理器都有各自的高速缓存(L1,L2,L3)，而主内存确只有一个 。 越靠近CPU的缓存越快也越小。所以L1缓存(一级缓存)很小但很快，并且紧靠着在使用它的CPU内核。L2大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。 当CPU执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。","text":"一、CPU和内存的交互在计算机中，CPU和内存的交互最为频繁，相比内存，磁盘读写太慢，内存相当于高速的缓冲区。 在多核CPU中，每个处理器都有各自的高速缓存(L1,L2,L3)，而主内存确只有一个 。 越靠近CPU的缓存越快也越小。所以L1缓存(一级缓存)很小但很快，并且紧靠着在使用它的CPU内核。L2大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。 当CPU执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。 从CPU到 大约需要的CPU 周期 大约需要的时间 主存 约60-80纳秒 QPI总线传输(between sockets, not drawn) 约20ns L3 cache 约40-45 cycles 约15ns L2 cache 约10 cycles 约3ns L1 cache 约3-4 cycles 约1ns 寄存器 1 cycle 二、缓存行数据在缓存中不是以独立的项来存储的，缓存是由缓存行组成的，通常是64字节，并且它有效地引用主内存中的一块地址。一个Java的long类型是8字节，因此在一个缓存行中可以存8个long类型的变量。非常奇妙的是如果你访问一个long数组，当数组中的一个值被加载到缓存中，它会额外加载另外7个。因此你能非常快地遍历这个数组。因此如果数据结构中的项在内存中不是彼此相邻的（链表），你将得不到免费缓存加载所带来的优势。并且在这些数据结构中的每一个项都可能会出现缓存未命中。 伪共享问题 （缓存行对齐提高效率）但这种加载有一个弊端。设想long类型的数据不是数组的一部分，它只是一个单独的变量。让我们称它为head。然后再设想有另一个变量tail紧挨着它。当加载head到缓存的时候同时也加载了tail。tail正在被你的生产者写入，而head正在被你的消费者写入。这两个变量实际上并不是密切相关的，而事实上却要被两个不同内核中运行的线程所使用。 设想消费者更新了head的值。缓存中的值和内存中的值都被更新了，而其他所有存储head的缓存行都会都会失效。请记住我们必须以整个缓存行作为单位来处理，不能只把head标记为无效。现在如果一些正在其他内核中运行的进程只是想读tail的值，整个缓存行需要从主内存重新读取。那么一个和你的消费者无关的线程读一个和head无关的值，它被缓存未命中给拖慢了。 硬件层数据一致性MESI(Modified Exclusive Shared Or Invalid)–CPU缓存一致性协议, 是一种广泛使用的支持写回策略的缓存一致性协议。 MESI协议中的状态CPU中每个缓存行（caceh line)使用4种状态进行标记，CPU在每个cache line 额外两位标记四种状态（使用额外的两位(bit)表示): M: 被修改（Modified)该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。 当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。 E: 独享的（Exclusive)该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。 S:共享的（Shared)该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。 I: 无效的（Invalid）该缓存是无效的（可能有其它CPU修改了该缓存行）。 三、乱序问题CPU为了提高指令执行效率，会在一条指令执行过程中（比如去内存读数据（慢100倍）），去同时执行另一条指令，前提是，两条指令没有依赖关系。 内存屏障(Memory Barrier) 保证特定情况下不乱序CPU执行指令可能是无序的，内存屏障有两个比较重要的作用 阻止屏障两侧指令重排序 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。 硬件内存屏障 X86 sfence: store| 在sfence指令前的写操作当必须在sfence指令后的写操作前完成。 lfence：load | 在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 mfence：modify/mix | 在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。 原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序 JVM级别如何规范（JSR133） LoadLoad屏障：在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障：在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore屏障：在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad屏障：在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。 volatile的实现细节 字节码层面 ACC_VOLATILE JVM层面, Volatile内存区的读写都加屏障 StoreStoreBarrier volatile 写操作 StoreLoadBarrier LoadLoadBarrier volatile 读操作 LoadStoreBarrier synchronized实现细节 字节码层面 ACC_SYNCHRONIZED monitorenter monitorexit JVM层面 C C++ 调用了操作系统提供的同步机制","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://github.com/casparthh/casparthh.github.io/tags/JVM/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"JVM - 类加载 & 初始化","slug":"ClassLoader","date":"2020-02-22T06:22:56.000Z","updated":"2020-02-23T08:38:35.801Z","comments":true,"path":"2020/02/22/ClassLoader/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/22/ClassLoader/","excerpt":"","text":"","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://github.com/casparthh/casparthh.github.io/tags/JVM/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"高并发与多线程 - Java容器","slug":"container","date":"2020-02-16T14:05:29.000Z","updated":"2020-02-23T08:38:35.799Z","comments":true,"path":"2020/02/16/container/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/16/container/","excerpt":"Java 容器容器 分两大类Collection、Map，Collection又分三大类List、Set、Queue队列 SetSet 与 List, Queue 的主要区别是不会有重复元素 ArrayList &amp; LinkedList 没有加锁，线程不安全。 ArrayList是基于数组实现的，LinkedList是基于双链表实现的。 LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向对列。 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。","text":"Java 容器容器 分两大类Collection、Map，Collection又分三大类List、Set、Queue队列 SetSet 与 List, Queue 的主要区别是不会有重复元素 ArrayList &amp; LinkedList 没有加锁，线程不安全。 ArrayList是基于数组实现的，LinkedList是基于双链表实现的。 LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向对列。 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。 Queue Queue 实现的实际上是一个队列，有进有出，它实现了很多对线程友好的API offer、peek、poll，他的一个子类型叫 BlockingQueue对线程友好的API又添加了put和take，这两个实现了阻塞操作，这个是在其他的List、 Set里面都是没有的。这里面最重要的就是是叫做阻塞队列，它的实现的初衷就是为了线程池、高并发做准备的。 Queue里面还有一个子接口叫Deque叫双端队列，一般的队列只是从一端往里扔从另一端往外取。 Deque就是说你可以从反方向装从另外一个方向取。 Queue Method Equivalent Deque Method 说明 add(e) addLast(e) 向队尾插入元素，失败则抛出异常 offer(e) offerLast(e) 向队尾插入元素，失败则返回false remove(e) removeFirst(e) 获取并删除首元素，失败则抛出异常 poll(e) pollFirst(e) 获取并删除首元素，失败则返回null element(e) getFirst(e) 获取但不删除首元素，失败则抛出异常 peek(e) peekFirst(e) 获取但不删除首元素，失败则返回null Vector &amp; HashTable最开始java1.0容器里只有两个，第一个叫Vector可以单独的往里扔，还有一个是Hashtable是可以一对一对往里扔的。Vector相对于实现了List接口，Hashtable实现了Map接口，Vector 和 Hashtable 自带锁所以性能低。 HashMapHashMap没有锁，线程不安全,他虽然速度比较快，但是多线程时数据会出问题。 Collections.synchronizedHashMapMap&lt;String,String&gt; map = Collections.synchronizedMap(new HashMap&lt;String,String&gt;());用的是SynchronizedMap这个方法，给HashMap我们手动加锁，它的源码自己做了一个Object，然后每次都是SynchronizedObject，严格来讲他和那个Hashtable效率上区别不大。 ConcurrentMap 接口ConcurrentHashMap &amp; ConcurrentSkipListMapConcurrentHashMap是多线程里面真正用的，提高效率主要提高在读上面，由于它往里插的时候内部又做了各种各样的判断，本来是链表的，到8之后又变成了红黑树，然后里面又做了各种各样的 CAS 的判断，所以他往里插的速度是要更低一些的。ConcurrentSkipListMap 通过跳表来实现的高并发容器并且这个Map是有排序的;这两个的区别一个是有序的一个是无序的，同时都支持并发的操作 CopyOnWriteCopyOnWriteArrayList &amp; CopyOnWriteArraySet &amp; CopyOnWriteMap写时复制，当Write的时候我们要进行复制。这个原码非常简单，当我们需要往里面加元素的时候，把里面的元素得复制出来，再添加一个位置存放新元素。 而且在写的时个有加锁，但在读的时候没有锁。在写的时候特别少，读的时候很多的情况下，在这个时候就可以考虑CopyOnWrite这种方式来提高效率。 1234567891011121314151617181920212223&#x2F;&#x2F;CopyOnWriteMap.put方法public V put(K key, V value) &#123; synchronized(this) &#123; Map&lt;K, V&gt; newMap &#x3D; new HashMap(this.internalMap); V val &#x3D; newMap.put(key, value); this.internalMap &#x3D; newMap; return val; &#125;&#125;&#x2F;&#x2F;CopyOnWriteArrayList.addpublic boolean add(E e) &#123; synchronized (lock) &#123; Object[] es &#x3D; getArray(); int len &#x3D; es.length; es &#x3D; Arrays.copyOf(es, len + 1); es[len] &#x3D; e; setArray(es); return true; &#125;&#125;&#x2F;&#x2F;CopyOnWriteArraySet 中实际是由CopyOnWriteArrayList存放的，在add的时候直接调用的CopyOnWriteArrayList.addIfAbsent(...) BlockingQueue 接口BlockingQueue的概念重点是在Blocking上，Blocking阻塞，Queue队列，是阻塞队列。BlockingQueue在 Queue的基础上又添加了两个方法，这两个方法一个叫put，一个叫take。这两个方法是真真正正的实现了阻塞。put往里装如果满了的话我这个线程会阻塞住，take往外取如果空了的话线程会阻塞住。所 以这个BlockingQueue就实现了生产者消费者里面的那个容器。 LinkedBlockingQueue用链表实现的BlockingQueue，是一个无界队列 ArrayBlockingqueueArrayBlockingQueue是有界的，可以指定它一个固定的值10，它容器就是10，那么当你往里面扔容器的时候，一旦他满了这个put方法就会阻塞住。然后你可以看看用add方法满了之后他会报异常。 offer用返回值来判断到底加没加成功，offer还有另外一个写法你可以指定一个时间尝试着往里面加1秒钟，1秒钟之后如果加不进去它就返回了. DelayQueueDelayQueue可以实现在时间上的排序，这个DelayQueue能实现按照在里面等待的时间来进行排序。 SynchronousQueueSynchronousQueue容量为0，就是这个东西它不是用来装内容的，SynchronousQueue是专门用来两 个线程之间传内容的，给线程下达任务。这个Queue和其他的很重要的区别就是 你不能往里头装东西，只能用来阻塞式的put调用，要求是前面得有人等着拿这个东西的时候你才可以 往里装，但容量为0，其实说白了就是我要递到另外一个的手里才可以。 TransferQueueTransferQueue传递，实际上是前面这各种各样Queue的一个组合，它可以给线程来传递任务，以此同时不像是SynchronousQueue只能传递一个，TransferQueue做成列表可以传好多个。比较牛X的是它添加了一个方法叫transfer，如果我们用put就相当于一个线程来了往里一装它就走了。transfer就是装完在这等着，阻塞等有人把它取走我这个线程才回去干我自己的事情。一般使用场景:是我做了一件事情，我这个事情要求有一个结果，有了这个结果之后我可以继续进行我下面的这个事情的时候，比方说 我付了钱，这个订单我付账完成了，但是我一直要等这个付账的结果完成才可以给客户反馈。 PriorityQueuePriorityQueue特点是它内部你往里装的时候并不是按顺序往里装的，而是内部进行了一个排序。","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Thread/"},{"name":"容器","slug":"容器","permalink":"https://github.com/casparthh/casparthh.github.io/tags/%E5%AE%B9%E5%99%A8/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"高并发与多线程 - 线程","slug":"thread","date":"2020-02-16T14:05:29.000Z","updated":"2020-02-23T08:38:35.793Z","comments":true,"path":"2020/02/16/thread/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/16/thread/","excerpt":"线程: 作为一个进程里面最小的执行单元它就叫一个线程，用简单的话讲一个程序里不同的执行路径就叫做一个线程 一、创建线程的几种方式： 继承Thread，并重写该类的run方法","text":"线程: 作为一个进程里面最小的执行单元它就叫一个线程，用简单的话讲一个程序里不同的执行路径就叫做一个线程 一、创建线程的几种方式： 继承Thread，并重写该类的run方法 1234567891011121314public class MyThread extends Thread&#123; @Override public void run()&#123; System.out.println(Thread.currentThread().getName()+\" 是继承写法。\"); &#125; public static void main(String[] args)&#123; MyThread thread = new MyThread(); thread.setName(\"extends thread\"); thread.start(); &#125;&#125; 通过Runnable接口创建线程类,创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 12345678910111213public class MyThread implements Runnable &#123; @Override public void run()&#123; System.out.println(Thread.currentThread().getName()+\" 写法。\"); &#125; public static void main(String[] args)&#123; Thread t = new Thread(new MyThread(),\"implements Runnable\"); t.start(); &#125;&#125; 通过Callable和Future创建线程 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值123456789101112131415161718192021public class MyCallableThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call()&#123; System.out.println(Thread.currentThread().getName()+\" 写法。\"); return 1; &#125; public static void main(String[] args)&#123; FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new MyCallableThread()); new Thread(task,\"implements Callable\").start(); try &#123; System.out.println(\"有返回值：\" + task.get()); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; catch (ExecutionException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 二、线程操作的几个方法 start: 启动一个新的线程,start方法必须子线程第一个调用的方法，start不能够重复调用，新线程会调用runnable接口提供的run方法 run: run方法是子线程的执行体，子线程从进入run方法开始直至run方法执行接收意味着子线程的任务执行接收， 在主线程直接调用run方法是不能创建子线程，只是普通方法调用 sleep: 睡眠，当前线程暂停一段时间让给别的线程去运行。Sleep是怎么复活由睡眠时间而定，等睡眠到规定的时间自动复活. Yield: 就是当前线程正在执行的时候停止下来进入等待队列，回到等待队列里在系统的调度算法里头，还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管 join: 意思就是在自己当前线程加入你调用Join的线程()，本线程等待。等调用的线程运行完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运行完毕继续t1运行(自己join自己没有意义) wait() 和 notify() 方法说明几点： 调用notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。 除了notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。 wait()法需要释放锁，所以必须在synchronized中使用，否则会抛出异常 IllegalMonitorStateException notify()方法也必须在synchronized中使用，并且应该指定对象 synchronized()、wait()、notify()对象必须一致，一个synchronized()代码块中只能有一个线程调 三、线程六种状态 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 阻塞(BLOCKED)：表示线程阻塞于锁。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 终止(TERMINATED)：表示该线程已经执行完毕。 *线程什么状态时候会被挂起?挂起是否也是一个状态?Running的时候，在一个cpu上会跑很多个线程，cpu会隔一段时间执行这个线程一下，在隔一段时间执行那个线程一下，这个是cpu内部的一个调度，从running扔回去就叫线程被挂起。 四、synchronized多个线程去访问同一个资源的时候对这个资源上锁 synchronized 使用方法和特性 在同步代码外嵌套synchronized(Object/Class) synchronized方法和synchronized(this)执行这段代码它是等值的 每次都定义个一个锁的对象Object o 把它new出来，那加锁的时候太麻烦每次都要new一个新的对象出来，所以呢，有一个简单的方式就是 synchronized(this)锁定当前对象就行 静态方法static是没有this对象的，你不需要new出一个对象来就能执行这个方法，但如果这个这个上面加一个synchronized的话就代表synchronized(T.class)。这里这个synchronized(T.class)锁的就是T类的对象 类锁和对象锁互不干扰，只有当监视的是同一个class（Class对象）的锁或同一个对象实例的锁才发生互斥 可重入，一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁 程序在执行过程中，如果出现异常，默认情况锁会被释放所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适， * 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。因此要非常小心的处理同步业务逻辑中的异常 如果锁的是new出来的对象，在某一种特定的不小心的情况下你把o变成了别的对象了，这个时候线程的并发就会出问题。锁是在对象的头上两位来作为代表的，你这线程本来大家都去访问这两位了，结果突然把 这把锁变成别的对象，去访问别的对象的两位了，这俩之间就没有任何关系了。因此，以对象作为锁的 时候不让它发生改变，加final。 五、锁升级的概念原来要去找操作系统，要找内核去申请这把锁，到后期做了对 synchronized的一些改进，他的效率比原来要改变了不少，改进的地方。当我们使用synchronized的 时候HotSpot的实现是这样的:上来之后第一个去访问某把锁的线程 比如sync (Object) ，来了之后先在 这个Object的头上面markword记录这个线程。(如果只有第一个线程访问的时候实际上是没有给这个 Object加锁的，在内部实现的时候，只是记录这个线程的ID(偏向锁))。偏向锁如果有线程争用的话，就升级为自旋锁，概念就是(有一个哥们儿在蹲马桶 ，另外来了一个哥 们，他就在旁边儿等着，他不会跑到cpu的就绪队列里去，而就在这等着占用cpu，用一个while的循环 在这儿转圈玩儿， 很多圈之后不行的话就再一次进行升级)。自旋锁转圈十次之后，升级为重量级锁，重量级锁就是去操作系统那里去申请资源。这是一个锁升级的过程。 六、volatile使一个变量在多个线程中可见，保证线程的可见性，同时防止指令重排序。线程可见性在CPU的级别是用缓存一直性来保 证的;禁止指令重排序CPU级别是你禁止不了的，那是人家内部运行的过程，提高效率的。但是在 虚拟机级别你家volatile之后呢，这个指令重排序就可以禁止。严格来讲，还要去深究它的内部的 话，它是加了读屏障和写屏障，这个是CPU的一个原语。A B线程都用到一个变量，java默认是A线程中保留一份copy,这样如果B线程修改了该变量，则A线程未必知道，使用volatile关键字，会让所有线程都会读到变量的修改值并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized 七、CAS 比较和交换（Conmpare And Swap)它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。凡是以Atomic开头的都是用CAS这种操作来保证线程安全的这么一些个类。AtomicInteger的意思就是里面包了一个Int类型，这个int类型的自增 count++ 是线程安全的，还有拿值等等是线程安全的，由于我们在工作开发中经常性的有那种需求，一个值所有的线程共同访问它往 上递增 ，所以jdk专门提供了这样的一些类。它的内部调用，就会跑到Unsafe类去(不安全的)，Unsafe中对CAS的实现是C++写的。也就是说AtomicInteger它的内部是调用了 Unsafe这个类里面的方法CompareAndSetI(CAS)。这个比较并且设定的意思是什么呢，我原来想改变某一个值0 ，我想把它变成1，但是其中我想做到线程安全，就只能加锁synchronized ，不然线程就不安全。我现在可以用另外一种操作来替代这把锁，就是cas操作，你可以把它想象成一个方法，这个方法有三个参数，cas(V，Expected，NewValue)。V第一个参数是要改的那个值;Expected第二个参数是期望当前的这个值会是几;NewValue要设定的新值。当前这个线程想改这个值的时候我期望你这值就是0，你不能是个1，如果是1就说明我这值不对，然后想把你变成1。当你判断的时候，发现是我期望的值，还没有进行新值设定的时候值发生了改变怎么办，cas是cpu的原语支持，也就是说cas操作是cpu指令级别上的支持，中间不能被打断。 ABA问题：假如说你有一个值，我拿到这个值是1，想把它变成2，我拿到1用cas操作，期望值是1，准备变成2，这个对象Object，在这个过程中，没有一个线程改过我肯定是可以更改的，但是 如果有一个线程先把这个1变成了2后来又变回1，中间值更改过，它不会影响我这个cas下面操作，这就是ABA问题。 这种问题怎么解决。如果是int类型的，最终值是你期望的，也没有关系，这种没关系可以不去管这个问题。如果你确实想管这个问题可以加版本号，做任何一个值的修改，修改完之后加一，后面检查的时候连带版本号一起检查。 八、Atomic 类AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的多线程对一个数进行递增方法: 一个long类型的数，递增的时候我们加锁; 使用AtomicLong可以让它不断的往上递增; LongAdder;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Incrementer &#123; static Long counter1 = new Long(0L); static AtomicLong counter2 = new AtomicLong(0L); static LongAdder counter3 = new LongAdder(); final static Object o = new Object(); public static void main(String[] args) &#123; //synchronized for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 100; j++) &#123; synchronized (o) &#123; //去掉锁之后结果就有问题 counter1= counter1+1; &#125; &#125; &#125;).start(); &#125; //AtomicLong for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 100; j++) &#123; counter2.incrementAndGet(); &#125; &#125;).start(); &#125; //LongAdder for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 100; j++) &#123; counter3.increment(); &#125; &#125;).start(); &#125; try &#123; //简单处理，休眠主线程等上面的计算线程完成。 TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(counter1); System.out.println(counter2); System.out.println(counter3); &#125;&#125; 九、基于CAS的一些新类型的锁1. RenentrantLock 可重入锁 ReentrantLock是可以替代synchronized的, 需要手动枷锁，手动解锁、可以出现多个不同的等待队列 ReentrantLock有一些功能还是要比synchronized强大的，强大的地方，你可以使用tryLock进行尝试 锁定，不管锁定与否，方法都将继续执行，synchronized如果搞不定的话他肯定就阻塞了，但是用 ReentrantLock你自己就可以决定你到底要不要wait。 原来写synchronized的地方换 写lock.lock()，加完锁之后需要注意的是记得lock.unlock()解锁，由于synchronized是自动解锁的，大括号执行完就结束了。lock就不行，lock必须得手动解锁，手动解锁一定要写在try…finally里面保证最好一定要解锁，不然的话上锁之后中间执行的过程有问题了，死在那了，别人就永远也拿不到这把锁了。 ReentrantLock还可以用lock.lockInterruptibly()这个类，对interrupt()方法做出相应，可以被打断的加锁，如果以这种方式加锁的话我们可以调用一个t2.interrupt(); 打断线程2的等待。 ReentrantLock还可以指定为公平锁，公平锁的意思是当我们new一个ReentrantLock你可以传一个参数为true，这个true表示公平锁，公平锁的意思是谁等在前面就先让谁执行，而不是说谁后来了之后就马上让谁执行。如果说这个锁不公平，来了一个线程上来就抢，它是有可能先抢到的。（是否公平锁分别有NonfairSync &amp; FairSync 两个不同的实现） 除了synchronized之外，多数内部都是用的cas。AQS的实际上它内部用的是 park和unpark，也不是全都用的cas,他还是做了一个锁升级的概念，只不过这个锁升级做的比较隐秘， 在等待这个队列的时候如果你拿不到还是进入一个阻塞的状态，前面至少有一个cas的状态，他不像原先就直接进入阻塞状态了。（参考后面的源码阅读部分） 1234567891011121314151617181920212223242526272829public class ReentrantLockTest &#123; static Integer i = new Integer(0); static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) &#123; for (int j = 0; j &lt; 10000; j++) &#123; new Thread(() -&gt; &#123; for (int k = 0; k &lt; 100 ; k++) &#123; lock.lock(); try &#123; i++; &#125; finally &#123; // 必须要必须要必须要手动释放锁,必须要必须要必须要手动释放锁,必须要必须要必须要手动释放锁(重要的事情说三遍) // 使用syn锁定的话如果遇到异常，jvm会手动释放锁，但是lock必须手动释放锁 lock.unlock(); &#125; &#125; &#125;).start(); &#125; try &#123; //简单处理，休眠主线程等上面的计算线程完成。 TimeUnit.SECONDS.sleep(5); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(i); &#125;&#125; ReentrantLock 非公平锁原码阅读 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 ReentrantLock lock &#x3D; new ReentrantLock(); lock.lock(); &#x2F;&#x2F;从断点跟踪 public void lock() &#123; sync.acquire(1); &#125; public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; final boolean nonfairTryAcquire(int acquires) &#123; final Thread current &#x3D; Thread.currentThread(); int c &#x3D; getState(); &#x2F;&#x2F;the current value of synchronization state. if (c &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;如果当前对象没有锁，直接设置一个排它锁 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123; &#x2F;&#x2F; 如果当前持有锁的是同一个线程，则设置为可重入 int nextc &#x3D; c + acquires; if (nextc &lt; 0) &#x2F;&#x2F; overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#x2F;&#x2F;没拿到锁，返回fallse &#125; private Node addWaiter(Node mode) &#123; &#x2F;&#x2F;mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared, &#x2F;&#x2F;now 一个共享锁或排它锁节点 Node node &#x3D; new Node(mode); &#x2F;&#x2F;取出队列中最后一个节点，设置为该新节点的上一个节点。并返回新节点。 &#x2F;&#x2F;如果最后一个节点为空，初使化一个同步队列 for (;;) &#123; Node oldTail &#x3D; tail; if (oldTail !&#x3D; null) &#123; node.setPrevRelaxed(oldTail); if (compareAndSetTail(oldTail, node)) &#123; oldTail.next &#x3D; node; return node; &#125; &#125; else &#123; initializeSyncQueue(); &#125; &#125;&#125;final boolean acquireQueued(final Node node, int arg) &#123; boolean interrupted &#x3D; false; try &#123; for (;;) &#123; final Node p &#x3D; node.predecessor(); &#x2F;&#x2F;取出前面新new 节点，判断上一个节点，是不是头部节点，如果是的话，直接再次尝试拿锁。 &#x2F;&#x2F;如果拿锁成功，那新节点，就是头部节点 if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next &#x3D; null; &#x2F;&#x2F; help GC return interrupted; &#125; &#x2F;&#x2F;判断是否继续自旋拿锁，还是park if (shouldParkAfterFailedAcquire(p, node)) interrupted |&#x3D; parkAndCheckInterrupt(); &#125; &#125; catch (Throwable t) &#123; cancelAcquire(node); if (interrupted) selfInterrupt(); throw t; &#125;&#125; 2.CountDownLatch倒数，Latch是门栓的意思(倒数的一个门栓，5、4、3、2、1数到了，我这个门栓就开 了)刚前面的递增方法，用的休眠主线程等计算线程完成后，再打印结果，这并不好，我们用CountDownLatch 改造下： 1234567891011121314151617181920212223242526272829303132public class Incrementer &#123; static Long counter1 = Long.valueOf(0); static CountDownLatch latch = new CountDownLatch(10000); public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 100; j++) &#123; synchronized (Incrementer.class) &#123; //去掉锁之后结果就有问题 counter1++; latch.countDown(); &#125; try &#123; TimeUnit.MILLISECONDS.sleep(10); //添加休眠，方便对比结果。 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; System.out.println(\"创建线程完成,等待结果。\"); try &#123; latch.await(); //这里会阻塞住，等latch 倒数到0的时候，才会继续执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(counter1); &#125;&#125; 3. CyclicBarrier循环栅栏，这有一个栅栏，什么时候人满了就把栅栏推倒， 哗啦哗啦的都放出去，出去之后扎栅栏又重新起来，再来人，满了，推倒之后又继续。 123456789101112131415161718192021222324252627282930public class BusDispatcher &#123; static CountDownLatch latch = new CountDownLatch(100); static volatile int num = 0; static CyclicBarrier barrier = new CyclicBarrier(10, ()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\" - 人满了发车。。。。。\"); &#125;); public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(()-&gt;&#123; try &#123; System.out.println(\"第\"+(++num)+\"个人上车\"); latch.countDown(); barrier.await(); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e)&#123; e.printStackTrace(); &#125; &#125;).start(); &#125; try &#123; latch.await(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(\"人车调度任务完成。\"); &#125;&#125; 4. PhaserPhaser它就更像是结合了CountDownLatch和CyclicBarrier，翻译一下叫阶段。Phaser是按照不同的阶段来对线程进行执行，就是它本身是维护着一个阶段这样的一个成员变量，当前 我是执行到那个阶段，是第0个，还是第1个阶段啊等等，每个阶段不同的时候这个线程都可以往前走， 有的线程走到某个阶段就停了，有的线程一直会走到结束。你的程序中如果说用到分好几个阶段执行 ， 而且有的人必须得几个人共同参与的一种情形的情况下可能会用到这个Phaser。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class PhaserTest &#123; static GamePhaser phaser = new GamePhaser(3); public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; sleepSeconds(1); System.out.println(Thread.currentThread().getName()+\" 到\"); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"玩第一个游戏。。。\"); sleepSeconds(2); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"玩第二个游戏。。。\"); sleepSeconds(3); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"玩第三个游戏。。。\"); sleepSeconds(4); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"玩第四个游戏。。。\"); sleepSeconds(5); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"准备离开。。。\"); sleepSeconds(2); phaser.arriveAndAwaitAdvance(); &#125;,\"00\"+(i+1)).start(); &#125; &#125; private static void sleepSeconds(int seconds) &#123; try &#123; TimeUnit.SECONDS.sleep(seconds); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class GamePhaser extends Phaser &#123; public GamePhaser(int parties) &#123; super(parties); &#125; /** * @param phase 第几个阶段， * @param registeredParties 当前有多少线程参与 * @return if this phaser should terminate, 是否要结束phaser */ @Override protected boolean onAdvance(int phase, int registeredParties) &#123; switch (phase) &#123; case 0: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"人到齐了开始玩第一个游戏^-^\"); System.out.println(\"\"); return false; case 1: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"开始玩第二个游戏^-^\"); System.out.println(\"\"); return false; case 2: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"开始玩第三个游戏^-^\"); System.out.println(\"\"); return false; case 3: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"开始玩第四个游戏^-^\"); System.out.println(\"\"); return false; case 4: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"游戏结束了，谢谢参与 ^-^\"); System.out.println(\"\"); return true; default: return true; &#125; &#125; &#125;&#125; 5. ReadWriteLock这个ReadWriteLock 是读写锁。读写锁的概念其实就是共享锁和排他锁，读锁就是共享锁，写锁就是排他锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ReadWriteLockTest &#123; static ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); static Lock readLock = readWriteLock.readLock(); static Lock writeLock = readWriteLock.writeLock(); static int value = 0; public static void main(String[] arges)&#123; for (int i = 0; i &lt; 10; i++) &#123; //读线程不用阻塞，可以并发完成工作 new Thread(()-&gt;&#123; readLock.lock(); try &#123; ReadWriteLockTest.read(); &#125; finally &#123; //记得Reentrant readLock.unlock(); &#125; &#125;).start(); &#125; //写线程会阻塞，需要排序完成任务 for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; writeLock.lock(); try &#123; ReadWriteLockTest.write(1); &#125; finally &#123; writeLock.unlock(); &#125; &#125;).start(); &#125; &#125; public static void read()&#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(\"read value =\" + value); &#125; public static void write(int num)&#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; value += num; System.out.println(\"write value =\" + value); &#125;&#125; 6. SemaphoreSemaphore 含义就是限流，比如说流水线人不能全去上洗手间吧，所以得限制，每个上洗手间的人必须要领到洗手卡才能去，没有卡的人得等着前面的人回来，并归还了卡。默认Semaphore是非公平的，new Semaphore(2, true)第二个值传true才是设置公平 1234567891011121314151617181920212223242526272829public class SemaphoreTest &#123; //定义限制数量 static Semaphore semaphore = new Semaphore(2, true); public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+\"想上厕所,排队领洗手卡。。。\"); semaphore.acquire(1); System.out.println(\"时间（秒）:\"+System.currentTimeMillis()/1000+\"，\"+Thread.currentThread().getName()+\"等到洗手卡了，上厕所ing。。。\"); TimeUnit.SECONDS.sleep(4); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; finally &#123; //用完了一定要记得归还release, 不然后边的人就没得用了。 semaphore.release(1); &#125; &#125;,\"姓名\"+(1+i)).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 7. Exchanger交换器，俩人之间互相交换个数据用的，这里收到的消息得是成对的，否则 Exchanger 一直在等待有人来交换。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ExchangerTest &#123; static Exchanger&lt;String&gt; exchanger = new Exchanger&lt;String&gt;(); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; String contents = exchanger.exchange(Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + \" 收到消息：\" + contents); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"thread 001\").start(); new Thread(() -&gt; &#123; try &#123; String contents = exchanger.exchange(Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + \" 收到消息：\" + contents); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"thread 002\").start(); new Thread(() -&gt; &#123; try &#123; String contents = exchanger.exchange(Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + \" 收到消息：\" + contents); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"thread 003\").start(); new Thread(() -&gt; &#123; try &#123; String contents = exchanger.exchange(Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + \" 收到消息：\" + contents); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"thread 004\").start(); &#125;&#125; 十、LockSuport*在JDK1.6中的java.util.concurrent的子包locks中引了LockSupport这个API，LockSupport是一个比较底层的工具类，用来创建锁和其他同步工具类的基本线程阻塞原语。java锁和同步器框架的核心 AQS: AbstractQueuedSynchronizer，就是通过调用 LockSupport.park()和 LockSupport.unpark()的方法，来实现线程的阻塞和唤醒的。 LockSuport的几个特点 LockSupport不需要synchornized加锁就可以实现线程的阻塞和唤醒 LockSupport.unpartk()可以先于LockSupport.park()执行，并且线程不会阻塞 如果一个线程处于等待状态，连续调用了两次park()方法，就会使该线程永远无法被唤醒 park()和unpark()方法的实现是由Unsefa类提供的，而Unsefa类是由C和C++语言完成的，它主要通过一个变量作为一个标识，变量值在0，1之间来回切换，当这个变量大于0的时候线程就获得了“令牌”，其实park()和unpark()方法就是在改变这个变量的值，来达到线程的阻塞和唤醒的1234567891011121314151617181920212223242526272829303132333435363738394041// LockSuport 要求用线程顺序打印A1B2C3....Z26public class PrintFactory &#123; static char[] letters = &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g'&#125;; static int[] nums = &#123;1, 2, 3, 4, 5, 6, 7&#125;; static Thread letterPrinter = new Thread(LetterThread::print); static Thread numPrinter = new Thread(NumThread::print); public static void main(String[] args) &#123; letterPrinter.start(); numPrinter.start(); &#125; static class LetterThread &#123; public static void print() &#123; for (int i = 0; i &lt; letters.length; i++) &#123; System.out.print(letters[i]); LockSupport.unpark(numPrinter); if(i &lt; letters.length -1)&#123; LockSupport.park(); &#125; &#125; &#125; &#125; static class NumThread &#123; public static void print() &#123; LockSupport.park(); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.print(nums[i]); LockSupport.unpark(letterPrinter); if(i &lt; letters.length -1)&#123; LockSupport.park(); &#125; &#125; &#125; &#125;&#125; 十一、Java的四种引用 强、软、弱、虚 比如Object o = new Object()，这就是普通的引用，也就是强引用，只要有一个应用指向这个对象，那么垃圾回收器一定不会回收它。 软引用 SoftReference&lt;byte[]&gt; m = new SoftReference&lt;&gt;(new byte[1024102410])当有一个对象(字节数组)被一个软引用所指向的时候，只有系统内存不够 用的时候，才会回收它(字节数组) 弱引用 WeakReference m = new WeakReference&lt;&gt;(new M())只要遭遇到gc就会回收 虚引用 PhantomReference phantomReference = new PhantomReference&lt;&gt;(new M(), QUEUE);对于虚引用它就干一件事，它就是管理堆外内存的，首先第一点，这个虚引用的构造方法至少都是两个参数的，第二个参数还必须是一个队列，这个虚引用基本没用，就是说不是给你用的，那么它是给谁用的呢?是给写JVM(虚拟机)的人用的 十二、JMHJMH -java Microbenchmark Harness微基准测试，它是测的某一个方法的性能。支持命令行或IDEA开发工具运行，idea运行需要添加插件。直接在Idea插件查找JMH安装。安装好后就可以像Junit一样写测试。官网 http://openjdk.java.net/projects/code-tools/jmh/Maven 引用： 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-core&lt;/artifactId&gt; &lt;version&gt;1.21&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess --&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt; &lt;version&gt;1.21&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 使用示例,代码写在test目录下，类似junit测试： 12345678@Benchmark@Warmup(iteration&#x3D;1, time&#x3D;3) &#x2F;&#x2F;在专业测试里面首先要进行预热，预热多少次，预热多少时间@Fork(5) &#x2F;&#x2F;用多少个线程去执行我们的程序 @BenchmarkMode(Mode.Throughput) &#x2F;&#x2F;是对基准测试的一个模式，这个模式用的最多的是 Throughput吞吐量@Measurement(iteration&#x3D;1, time&#x3D;3) &#x2F;&#x2F;是整个测试要测试多少遍，调用这个方法要调用多少次public void test() &#123; &#x2F;&#x2F;.... 调用测试方法&#125; 十三、Disrupter主页：http://lmax-exchange.github.io/disruptor/ 源码：https://github.com/LMAX-Exchange/disruptor GettingStarted: https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started api: http://lmax-exchange.github.io/disruptor/docs/index.html maven: https://mvnrepository.com/artifact/com.lmax/disruptor ifeve：http://ifeve.com/disruptor/ Disruptor 开源的并发框架，并获得2011 Duke’s 程序框架创新奖，能够在无锁的情况下实现网络的Queue并发操作。 如果把它用作MQ的话，单机最快的MQ，性能非常的高，主要是它里 用的全都是CAS, 另外把各种各样的性能开发到了极致。 Disruptor就是在内存里，Disruptor简单理解就是内存里用于存放元素的一个高效率的队列。 Disruptor叫无锁、高并发、环形Buffer，直接覆盖(不用清除)旧的数据，降低GC频率，用于生产者消费者模式 RingBuffer是一个环形队列，和其他队列不一样的是他是一个环形队列，环形的Buffer。一般情况下我们的容器是一个队列，不管你是用链表实现还是用数组实现的，它会是一个队列，那么这个队列生产者这边使劲往里塞，消费者这边使劲往外拿，但Disruptor的核心是一个环形的buffer。 RingBuffer的序号，指向下一个可用的元素 采用数组实现，没有首尾指针对比ConcurrentLinkedQueue，用数组实现的速度更快假如长度为8，当添加到第12个元素的时候在哪个序号上呢?用12%8决定当Buffer被填满的时候到底是覆盖还是等待，由Produce决定 长度设为2的n次幂，利于二进制计算，例如:12%8=12&amp;(8-1) 等待策略 (常用)BlockingWaitStrategy:通过线程堵塞的方式，等待生产者唤醒，被唤醒后，再循环检查依赖的sequence是否已经消费。 BusySpinWaitStrategy:线程一直自旋等待，可能比较耗cpu LiteBlockingWaitStrategy:线程阻塞等待生产者唤醒，与BlockingWaitStrategy相比，区别在 signalNeeded.getAndSet，如果两个线程同时访问一个访问waitfor，一个访问signalAll时，可以减少lock加锁次数 LiteTimeoutBlockingWaitStrategy:与LiteBlockingWaitStrategy相比，设置了阻塞时间，超过时间后抛出异常 PhasedBackoffWaitStrategy:根据时间参数和传入的等待策略来决定使用那种等待策略 TimeoutBlockingWaitStrategy:相对于BlockingWaitStrategy来说，设置了等待时间，超过后抛出异常 (常用)YieldingWaitStrategy:尝试100次，然后Thread.yield()让出cpu (常用)SleepingWaitStrategy:sleep","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Thread/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"高并发与多线程 - 线程池","slug":"ThreadPool","date":"2020-02-16T13:05:29.000Z","updated":"2020-02-23T08:38:35.803Z","comments":true,"path":"2020/02/16/ThreadPool/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/16/ThreadPool/","excerpt":"一、Executor执行者，是一个接口类，他有一个方法叫执行，那么执行的东西是 Runnable。 二、ExecutorService是从Executor继承，除了去实现Executor可以去执行一个任务之外，还完善了整个任务执行器的一个生命周期，就拿线程池来举例子，一个线程池里面一堆的线程就是一堆的工人，执行完一个任务之后我这个线程怎么结束啊；线程池定义了这样一些个方法： void shutdown();//结束 List shutdownNow();//马上结束 boolean isShutdown();//是否结束了 boolean isTerminated();//是不是整体都执行完了 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;//等着结束，等多长时间，时间到了还不结束的话他 就返回false Future submit(Callable task); Future&lt;?&gt; submit(Runnable task); List&lt;Future&gt; invokeAll(Collection&lt;? extends Callable&gt; tasks) throws InterruptedException; T invokeAny(Collection&lt;? extends Callable&gt; tasks) throws InterruptedException, ExecutionException;","text":"一、Executor执行者，是一个接口类，他有一个方法叫执行，那么执行的东西是 Runnable。 二、ExecutorService是从Executor继承，除了去实现Executor可以去执行一个任务之外，还完善了整个任务执行器的一个生命周期，就拿线程池来举例子，一个线程池里面一堆的线程就是一堆的工人，执行完一个任务之后我这个线程怎么结束啊；线程池定义了这样一些个方法： void shutdown();//结束 List shutdownNow();//马上结束 boolean isShutdown();//是否结束了 boolean isTerminated();//是不是整体都执行完了 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;//等着结束，等多长时间，时间到了还不结束的话他 就返回false Future submit(Callable task); Future&lt;?&gt; submit(Runnable task); List&lt;Future&gt; invokeAll(Collection&lt;? extends Callable&gt; tasks) throws InterruptedException; T invokeAny(Collection&lt;? extends Callable&gt; tasks) throws InterruptedException, ExecutionException; 123456789101112public class ExecutroServiceTest &#123; public static void main(String[] args) &#123; ExecutorService es = Executors.newCachedThreadPool(); FutureTask&lt;Integer&gt; task = new FutureTask(() -&gt; &#123; System.out.println(\"Executor Service Test\"); return 1; &#125;); es.execute(task); es.shutdownNow(); &#125;&#125; 他是实现了一些个线程的线程池的生命周期的东西，扩展了Executor的接口，真正的线程池的现实是在ExecutorService的这个基础上来实现的。ExecutorService的时候你会发现他除了Executor执行任务之外还有submit提交任务，执行任务是直接拿过来马上运行，而submit是扔给这个线程池，什么时候运行由这个线程池来决定，相当于 是异步的，我只要往里面一扔就不管了。那好，如果不管的话什么时候他有结果啊，这里面就涉及了比较新的类:比如说Future、RunnableFuture、FutureTask。 三、Callable以前定义一个线程的任务只能去实现Runnable接口，那在1.5之后他就增加了Callable这个接口。Callable是什么，他类似于Runnable，不过 Callable可以有返回值。 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 四、FutureFuture代表的是那个Callable被执行完了之后我怎么才能拿到那个结果啊，它会封装到一个Future里面。Future将来，未来。未来你执行完之后可以把这个结果放到这个未来有可能执行完的结果里头，所以Future代表的是未来执行完的一个结果。把Callable的任务扔给线程池，线程池异步的执行完了，就是把任务交给线程池之后，调用get方法直到有结果之后get会返回。Callable一般是配合线程池和Future来用的。 五、FutureTask其实更灵活的一个用法是FutureTask，即是一个Future同时又是一个Task，原来这Callable只能一个Task只能是一个任务但是他不能作为一个Future来用。这个FutureTask相当于是我自己可以作为一个任务来用，同时这个任务完成之后的结果也存在于这个对象里，为什么他能做到这一点，因 为FutureTask他实现了RunnableFuture，而RunnableFuture即实现了Runnable又实现了Future，所以他即是一个任务又是一个Future 12345678910public class FutrueTaskTest &#123; public static void main(String[] args) &#123; FutureTask task = new FutureTask(()-&gt;&#123; System.out.println(\"future task test\"); return 1; &#125;); new Thread(task).start(); &#125;&#125; 六、CompletableFutureCompletableFuture他的底层用的是ForkJoinPool，底层特别复杂，但是用法特别灵活。 七、目前JDK提供的有两种类型 ThreadPoolExecutor 普通的线程池 ForkJoinPool 八、ThreadPoolExecutorThreadPoolExecutor他的父类是AbstractExecutorService，AbstractExecutorService 实现了 ExecutorService，再ExecutorService的父类是Executor，所以ThreadPoolExecutor就相当于线程池的执行器 定义这一个线程池，这里面的七个参数: corePoolSoze 核心线程数，最开始的时候是有这个线程池里面是有一定的核心线程数 的; maximumPoolSize 最大线程数，线程数不够了，能扩展到最大线程是多少; keepAliveTime 生存时间，意思是这个线程有很长时间没干活了请你把它归还给操作系 TimeUnit.SECONDS 生存时间的单位到底是毫秒纳秒还是秒自己去定义; 任务队列，就是我们前面讲的BlockingQueue，各种各样的BlockingQueue都可以; 线程工厂, 要去实现ThreadFactory的接口，这个接口只有一个方法叫newThread，所以就是产生线程的，可以通过这种方式产生自定义的线程，默认产生的是defaultThreadFactory，而defaultThreadFactory 产生线程的时候有几个特点: new出来的时候指定了group制定了线程名字，然后指定的这个线程 绝对不是守护线程，设定好你线程的优先级。自己可以定义产生的到底是什么样的线程，指定线程名叫什么(为什么要指定线程名称，有什么意义，就是可以方便出错是回溯); 拒绝策略，指的是线程池忙，而且任务队列满这种情况下我们就要执行各种各样的拒绝策略，jdk默认提供了四种拒绝策略，也是可以自定义的。 1:Abort:抛异常 2:Discard:扔掉，不抛异常 3:DiscardOldest:扔掉排队时间最久的 4:CallerRuns:调用者处理服务一般情况这四种我们会自定义策略，去实现这个拒绝策略的接口，处理的方式是一般我们的消息需要保存下来，并且记录日志。 九、JDK给我们提供了一些默认的线程池的实现1. SingleThreadPool只有一个线程，这个一个线程的线程池可以保证我们扔进去的任务是顺序执行的。 12345678ExecutorService service &#x3D; Executors.newSingleThreadExecutor();public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 2. CachedThreadPoolCachedThreadPool的特点，就是你来一个任务我给你启动一个线程，当然前提是我的线程池里面有线程存在而且他还没有到达60秒钟的回收时间的时候，来一个任务，如果有线程存在我就用现有的线程，但是在有新的任务来的时候，如果其他线程忙就启动一个新的，CachedThreadPool用的任务队列是 synchronousQueue，它是一个手递手容量为空的Queue，就是你来一个东西必须得有一个线程把他拿走，不然我提交任务的线程从这阻塞住了。 123456ExecutorService executor &#x3D; Executors.newCachedThreadPool();public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 3. FixedThreadPoolFixedThreadPool指定一个参数，到底有多少个线程，你看他的核心线程和最大线程都是固定的，因为他的最大线程和核心线程都是固定的就没有回收之说，所以把keepAliveTime指定成0，这里用的是LinkedBlockingQueue 123456ExecutorService executor &#x3D; Executors.newFixedThreadPool(10);public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 4. ScheduledPool定时任务线程池，隔一段时间之后这个任务会执行。这个就是我们专门用来执行定时任务的一个线程池。看源码，我们newScheduledThreadPool的时 候他返回的是ScheduledThreadPoolExecutor，然后在ScheduledThreadPoolExecutor里面他调用了 super，他的super又是ThreadPoolExecutor，它本质上还是ThreadPoolExecutor，所以并不是别的，参数还是ThreadPool的七个参数。这是专门给定时任务用的这样的一个线程池。 1234567891011ExecutorService executor &#x3D; Executors.newScheduledThreadPool(10);public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125; 5. WorkStealingPool (它实际上是new了一个ForkJoinPool)WorkStealing指的是和原来线程池的区别每一个线程都有自己单独队列，所以任务不断往里扔的时候它会在每一个线程的队列上不断的累积，让某一个线程执行完自己的任务之后就回去另外一个线程上面偷，所以这个叫WorkStealing。 12345678ExecutorService executor &#x3D; Executors.newWorkStealingPool();public static ExecutorService newWorkStealingPool() &#123; return new ForkJoinPool (Runtime.getRuntime().availableProcessors(), ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; 6. ForkJoinPool它适合把大任务切分成一个一个的小任务去运行，小任务还是觉得比较大，再切。切完这个任务执行完了要进行一个汇总。 7. Cache vs Fixed什么时候用Cache什么时候用Fixed，你得精确的控制有多少个线程数，控制数量问题多数情况下得预估并发量。如果线程池中的数量过多，最终他们会竞争稀缺的处理器和内存资源，浪费大量的时间在上下文切换上，反之，如果线程的数目过少，正如你的应用所面临的情况，处理器的一些核可能就无法充分利用。《Java并发编程实战》作者 Brian Goetz建议，线程池大小与处理器的利用率之比可以使用公式来进行计算估算:线程池=你有多少个cpu 乘以 cpu期望利用率 乘以 (1+ W/C)。W除以C是等待时间与计算时间的比率。 十、线程池的一些5种状态 RUNNING:正常运行的; SHUTDOWN:调用了shutdown方法了进入了shutdown状态; STOP:调用了shutdownnow马上让他停止; TIDYING:调用了shutdown然后这个线程也执行完了，现在正在整理的这个过程叫TIDYING; TERMINATED:整个线程全部结束;","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Thread/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"Angular入门","slug":"angular入门","date":"2020-02-10T14:09:42.000Z","updated":"2020-02-11T00:35:49.028Z","comments":true,"path":"2020/02/10/angular入门/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/10/angular%E5%85%A5%E9%97%A8/","excerpt":"Angular 环境搭建1、安装前准备工作： 1.1、安装nodejs 安装nodejs的计算机上面必须安装nodejs, 建议安装最新稳定版本 $ node -v 1.2、安装cnpm npm可能安装包会失败，建议先用npm安装一下cnpm用淘宝镜像安装 $ npm install -g cnpm –registry=https://registry.npm.taobao.org 2、使用 npm/cnpm 命令安装 angular/cli (只需要安装一次) $ npm install -g @angular/cli 或者 cnpm install -g @angular/cli","text":"Angular 环境搭建1、安装前准备工作： 1.1、安装nodejs 安装nodejs的计算机上面必须安装nodejs, 建议安装最新稳定版本 $ node -v 1.2、安装cnpm npm可能安装包会失败，建议先用npm安装一下cnpm用淘宝镜像安装 $ npm install -g cnpm –registry=https://registry.npm.taobao.org 2、使用 npm/cnpm 命令安装 angular/cli (只需要安装一次) $ npm install -g @angular/cli 或者 cnpm install -g @angular/cli Angular 创建项目1、打开命令行工具找到你要创建项目的目录2、创建项目 ng new 项目名称 直接安装: $ ng new angulardemo 如果要跳过npm i 安装: $ ng new angulardemo –skip-install 再手动用cnpm install 代替npm i安装 $ cd angulardemo $ cnpm install3、运行项目 $ ng serve –open 访问：http://localhost:4200","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Angular/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E5%89%8D%E7%AB%AF/"}]}]}