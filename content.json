{"meta":{"title":"永远晴天的博客","subtitle":"面朝大海，春暖花开","description":"description","author":"Caspar Tan","url":"https://github.com/casparthh/casparthh.github.io"},"pages":[{"title":"About me","date":"2020-02-10T13:29:44.000Z","updated":"2020-02-22T14:43:29.662Z","comments":true,"path":"about/index.html","permalink":"https://github.com/casparthh/casparthh.github.io/about/index.html","excerpt":"","text":"个人介绍还没想好和大家说什么^_^ 联系方式QQ : 591926730Email : tanhuanghui@sina.com"}],"posts":[{"title":"Twemproxy(Nutcracker)","slug":"twemproxy","date":"2020-03-07T16:45:46.000Z","updated":"2020-03-07T17:25:23.972Z","comments":true,"path":"2020/03/08/twemproxy/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/03/08/twemproxy/","excerpt":"Twtter 开源的一个 Redis 和 Memcache 代理服务器，主要用于管理 Redis 和 Memcached 集群。","text":"Twtter 开源的一个 Redis 和 Memcache 代理服务器，主要用于管理 Redis 和 Memcached 集群。 编译git :https://github.com/twitter/twemproxy下载源码安装依赖工具$ yum install automake libtool 添加阿里云epel repository$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo$ yum clean all 查找新版本的autoconf$ yum search autoconf$ yum install autoconf268 从源码编译$ makereconf -fvi$ ./configure$ make 安装编译完成后进入script目录下，可以找到nutcracker.init文件，这是个脚本文件可以打开看下。里面有指定了a. chkconfigb. 执行程序： prog=”nutcracker”c. 配置文件nutcracker.yml： OPTIONS=”-d -c /etc/nutcracker/nutcracker.yml” 接下来需要做的就是：1.将这个脚本文件复制到 /etc/init.d/$ cp nutcracker.init /etc/init.d/nutcracker$ chmod +x /etc/init.d/nutcracker 2.回到编译目录下找到nutcracker.yml配置文件并复制到/tec/nutcracker/目录下$ mkdir /etc/nutcracker$ cp ./conf/nutcracker.* /etc/nutcracker/ 3.在编译文件的src目录下找到程序nutcracker,并复制到/usr/bin/下$ cp ./src/nutcracker /usr/bin/ 4.修改nutcracker文件中有配置好了几个参考模版。我们只需保留任意一个，然后修改services部分指向redis master就行。 1234567891011alpha: listen: 127.0.0.1:22121 hash: fnv1a_64 distribution: ketama auto_eject_hosts: true redis: true server_retry_timeout: 2000 server_failure_limit: 1 servers: - vm1:6379:1 - vm3:6379:1 auto_eject_host: 当连接一个server失败次数超过server_failure_limit值时，是否把这个server驱逐出集群，默认是falseserver_retry_timeout:单位毫秒，当auto_eject_host打开后，重试被临时驱逐的server之前的等待时间server_failure_limit: 当auto_eject_host打开后，驱逐一个server之前重试次数 运行测试启动服务$ service nutcracker start 连接到代理程序并测试 123$ redis-cli -p 22121set pass mypasswordset k1 mytestk1 set 多个key 后再分别到多台master上get 验证，由于算法原因，可能会连续很多key存到了同一台redis, 所以多set一些不同的key验证。 其缺点：不支持Redis的事务操作。不支持针对多个值的操作，比如取sets的子交并补等。","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Redis/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"高并发 - 基于Keepalived的LVS实验","slug":"keepalivedlvs","date":"2020-03-02T23:50:49.411Z","updated":"2020-03-02T23:50:49.411Z","comments":true,"path":"2020/03/03/keepalivedlvs/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/03/03/keepalivedlvs/","excerpt":"","text":"准备环境vip：node01 192.168.79.101 lvs(主)：node01 192.168.79.101 网卡: eth0lvs(备)：node04 192.168.79.104 网卡: eth0 nginx1：node02 192.168.79.102 网卡: eth3nginx2：node03 192.168.79.103 网卡: eth3 RS中的服务node02~node03:1)修改内核： echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce2）设置隐藏的vip： ifconfig lo:3 192.168.79.110 netmask 255.255.255.255 3)在node02 &amp; node03上安装nginx 1234567891011121314151617181920212223## 解压tar -xf nginx-1.16.1.tar.gz## 安装编译工具及库文件 yum -y install gcc pcre-devel zlib-devel openssl openssl-devel## 配置编译安装cd nginx-1.16.1.&#x2F;configure --sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx --conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.conf --pid-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid --with-http_ssl_modulemake &amp; make install## 分别修改index.html 加上ip 或内容区分是如台机，方便后续测试vi &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;index.html## 启动nginx.&#x2F;nginx分别访问检查是否安装成功，如果服务正常开启，但主机访问不了，请检查防火墙service iptables stophttp:&#x2F;&#x2F;192.168.79.102&#x2F;http:&#x2F;&#x2F;192.168.79.103&#x2F; 安装ipvsadm &amp; keepalived在node01 &amp; node04 安装 ipvsadm 和 keepalived 1234567## 安装lvs的管理工具ipvsadmyum install ipvsadm keepalived -y## 配置cd &#x2F;etc&#x2F;keepalived&#x2F;cp keepalived.conf keepalived.conf.bakvi keepalived.conf keepalived 配置文件内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384! Configuration File for keepalived## 全局默认配置，发生故障时邮件通知global_defs &#123; notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.79.1 smtp_connect_timeout 30 router_id LVS_DEVEL&#125;## 虚拟路由冗余协议！vrrp_instance VI_1 &#123; ## state MASTER|BACKUP：当前节点在此虚拟路由器上的初始状态；只能有一个是MASTER，余下的都应该为BACKUP； ##node4 这里写 BACKUP state MASTER ## 绑定为当前虚拟路由器使用的物理接口； interface eth0 ## 当前虚拟路由器的惟一标识，范围是0-255 virtual_router_id 51 ## 当前主机在此虚拟路径器中的优先级；范围1-254； ## node4 这里小点，写 50 priority 100 ## vrrp通告的时间间隔； advert_int 1 ## 设置认证 authentication &#123; auth_type PASS auth_pass 1111 &#125; # 定义vip virtual_ipaddress &#123; 192.168.79.110&#x2F;24 dev eth0 label eth0:1 &#125;&#125;virtual_server 192.168.79.110 80 &#123; ## 每隔6秒查看realserver状态 delay_loop 6 ## 调度算法改为轮询调度 lb_algo rr # lvs工作模式为DR|NAT|TUN模式 lb_kind DR nat_mask 255.255.255.0 # 同一IP 的连接50秒内被分配到同一台realserver(测试时改为0) persistence_timeout 0 protocol TCP ## 定义realserver real_server 192.168.79.102 80 &#123; weight 1 HTTP_GET &#123; url &#123; path &#x2F; status_code 200 &#125; ## 三秒无响应超时 connect_timeout 3 nb_get_retry 3 delay_before_retry 3 &#125; &#125; ## 定义realserver real_server 192.168.79.103 80 &#123; weight 1 HTTP_GET &#123; url &#123; path &#x2F; status_code 200 &#125; ## 三秒无响应超时 connect_timeout 3 nb_get_retry 3 delay_before_retry 3 &#125; &#125;&#125; 查看keepalived配置帮助文档12345678910111213man 5 keepalived.conf## 查看virtual_ipaddress 配置说明virtual_ipaddress &#123; &lt;IPADDR&gt;&#x2F;&lt;MASK&gt; brd &lt;IPADDR&gt; dev &lt;STRING&gt; scope &lt;SCOPE&gt; label &lt;LABEL&gt; 192.168.200.17&#x2F;24 dev eth1 192.168.200.18&#x2F;24 dev eth2 label eth2:1&#125; ## brd &lt;IPADDR&gt;: 桥接器地址## dev &lt;STRING&gt;: 设备## scope &lt;SCOPE&gt;: 权重值 ## label &lt;LABEL&gt;: 标签 启动 &amp; 验证 keepalived12345678910111213141516171819202122232425## 启动keepalivedservice keepalived start## 检查网卡是否添加成功ifconfig## 主需要显示信息，主正常的时候备没有：eth0:1 Link encap:Ethernet HWaddr 00:0C:29:6F:93:B0 inet addr:192.168.79.110 Bcast:0.0.0.0 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1## 检查lvs内核模块的配置：ipvsadm -ln## 需要显示信息：IP Virtual Server version 1.2.1 (size&#x3D;4096)Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConnTCP 192.168.79.110:80 rr -&gt; 192.168.79.102:80 Route 1 0 0 -&gt; 192.168.79.103:80 Route 1 0 0 ## 查看负载记录：ipvsadm -lnc 测试* 用浏览器访问http://192.168.79.100 验证结果* 分别停掉一台DR 或 主，备 再检验结果 将DR 的隐藏IP配置写成文件创建lvsdr.sh，内容如下： 12345678910#!&#x2F;bin&#x2F;shVIP&#x3D;192.168.79.110# 限制arp请求echo &quot;1&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_ignoreecho &quot;1&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignoreecho &quot;2&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;lo&#x2F;arp_announceecho &quot;2&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announceifconfig lo:3 $VIP netmask 255.255.255.255","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"https://github.com/casparthh/casparthh.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"LVS","slug":"LVS","permalink":"https://github.com/casparthh/casparthh.github.io/tags/LVS/"},{"name":"Keepalived","slug":"Keepalived","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Keepalived/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"高并发 - 负载均衡架构","slug":"loadbalance","date":"2020-03-02T23:43:30.737Z","updated":"2020-03-02T23:43:30.737Z","comments":true,"path":"2020/03/03/loadbalance/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/03/03/loadbalance/","excerpt":"","text":"","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"https://github.com/casparthh/casparthh.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"高并发 - 网络协议原理","slug":"tcpip","date":"2020-03-01T08:53:16.000Z","updated":"2020-03-02T23:43:54.051Z","comments":true,"path":"2020/03/01/tcpip/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/03/01/tcpip/","excerpt":"计算机网络体系结构分层 OSI 七层模型 TCP/IP 概念层模型 功能 TCP/IP 协议 应用层 应用层 文件传输，电子邮件，文件服务 ，虚拟终端 TFTP,HTTP,SMTP,FTP,SNTP,DNS,Telnet 表示层 数据格式化，代码转换，数据加密 没有协议 会话层 解除或建立与的接点的联系 没有协议 传输层 传输层 提供端对端的接口 TCP,UDP 网络层 网络层 为数据包选择路由 IP,ICMP,RIP,OSPF,BCP,ICMP 数据链路层 链路层 传输有地址的帧以及错误检测功能 SLIP,CSLIP,PPP,ARP,RARP,MTU 物理层 以二进制数据型式在物理媒体上传数数据 ISO2110,IEEE802,IEEE802.2","text":"计算机网络体系结构分层 OSI 七层模型 TCP/IP 概念层模型 功能 TCP/IP 协议 应用层 应用层 文件传输，电子邮件，文件服务 ，虚拟终端 TFTP,HTTP,SMTP,FTP,SNTP,DNS,Telnet 表示层 数据格式化，代码转换，数据加密 没有协议 会话层 解除或建立与的接点的联系 没有协议 传输层 传输层 提供端对端的接口 TCP,UDP 网络层 网络层 为数据包选择路由 IP,ICMP,RIP,OSPF,BCP,ICMP 数据链路层 链路层 传输有地址的帧以及错误检测功能 SLIP,CSLIP,PPP,ARP,RARP,MTU 物理层 以二进制数据型式在物理媒体上传数数据 ISO2110,IEEE802,IEEE802.2 ### 应用层协议演示 * 建立连接 12cd &#x2F;proc&#x2F;$$&#x2F;fdexec 8&lt;&gt; &#x2F;dev&#x2F;tcp&#x2F;www.baidu.com&#x2F;80 $$当前进程ID fd:文件描述符 执行完后再执行ll 可以查看到多了一个socket连接 传送数据（http协议：规范标准）1echo -e &#39;GET &#x2F; HTTP&#x2F;1.0\\n&#39; &gt;&amp;8 GET / HTTP/1.0：HTTP 协议规定的 Request 请求头最小的写法GET: 请求方法/: URL请求资源HTTP/1.0： HTTP 协议版本 -e 识别\\n换行符echo 打印Request信息重定向到文件描述符8 Socket里，Socket会发送到百度 查看结果1cat &lt;&amp; 8 传输控制层 TCP三次握手四次挥手 三次握手在socket通过TCP协议进行数据连接时，客户端在连接上服务端后会有一个三次握手的过程 客户端：我可以和你传输数据吗 服务端：可以 客户端：好的我来了 四次挥手在socket端开连接时，会有一个四次挥手的过程 我要断开连接了 好的，我先处理完手中的任务 好的，我等你 断开吧 三次握手&gt;数据传输&gt;四次分手 成为一个最小粒度,不可被分割 查看当前所有Socket连接信息：netstat -natpn: 显示ip地址，不要用逻辑名称a: 所有t: 查看当前所有的socket链接p: PID，显示通信是哪个进程的ID号 网络层下一跳寻址cat /etc/sysconfig/network-scripts/ifcfg-eth1IPADDR=192.168.79.101GATEWAY=192.168.79.2NETMASK=255.255.255.0IP地址，点分字节，通信每一个点的标识符，IP是端点间，MAC地址是节点间的 TCP/IP协议：基于下一跳的机制, 每一台互联网设备的内存中，不需要存储全网数据，只需要存周边一步之内的数据IP地址与掩码发生二进制的按位与计算: 192.168.79.101 &amp; 255.255.255.0得出这台机器的网络号是：192.168.79.0； 当前机器是这个网络中的第101号。 查看路由表路由表：存储了本地计算机可以到达的网络目的地址范围和如何到达的路由信息。路由表是TCP/IP通信的基础，本地计算机上的任何TCP/IP通信都受到路由表的控制。 1234route -nDestination Gateway Genmask Flags Metric Ref Use Iface192.168.79.0 0.0.0.0 255.255.255.0 U 1 0 0 eth10.0.0.0 192.168.79.2 0.0.0.0 UG 0 0 0 eth1 U 表示该路由可以使用。 G 该路由是到一个网关（路由器） 1） 网络地址（Network Destination）、网络掩码（Netmask）网络地址和网络掩码相与的结果用于定义本地计算机可以到达的目的网络地址范围。 2） 网关（Gateway，又称为下一跳服务器）在发送IP数据包时，网关定义了针对特定的网络目的地址，数据包发送到的下一跳服务器。如果是本地计算机直接连接到的网络，网关通常是0.0.0.0。如果是远程网络或默认路由，网关通常是本地计算机所连接到的网络上的某个服务器或路由器。 3） 接口（Interface）接口定义了针对特定的网络目的地址，本地计算机用于发送数据包的网络接口。 (4) 跃点数（Metric）跃点数用于指出路由的成本，通常情况下代表到达目标地址所需要经过的跃点数量，一个跃点代表经过一个路由器。跃点数越低，代表路由成本越低；跃点数越高，代表路由成本越高。当具有多条到达相同目的网络的路由项时，TCP/IP会选择具有更低跃点数的路由项。 123456#route add 添加路由#使用route 命令添加的路由，机器重启或者网卡重启后路由就失效了route add -net 192.168.88.88 netmask 255.255.255.255 gw 192.168.79.102#删除一条路由,删除的时候不用写网关route del -net 192.168.79.0 netmask 255.255.255.0 路由确定过程当TCP/IP需要向某个IP地址发起通信时，它会对路由表进行评估，以确定如何发送数据包。评估过程如下：(1) TCP/IP使用需要通信的目的IP地址和路由表中每一个路由项的网络掩码进行相与计算，如果相与后的结果匹配对应路由项的网络地址，则记录下此路由项。(2) 当计算完路由表中所有的路由项后， (a) TCP/IP选择记录下的路由项中的最长匹配路由（网络掩码中具有最多“1”位的路由项）来和此目的IP地址进行通信。 (b) 如果存在多个最长匹配路由，那么选择具有最低跃点数的路由项。 (c) 如果存在多个具有最低跃点数的最长匹配路由，那么：均根据最长匹配路由所对应的网络接口在网络连接的高级设置中的绑定优先级来决定(一般有线(eth0) &gt; 无线 (wlan0) &gt; 移动信号(4G))。 (d) 如果优先级一致，则选择最开始找到的最长匹配路由。 链路层数据包的封装传输层及其以下的机制由内核提供，应用层由用户进程提供，数据在传输之前，必须要进行封装。链路层也可以叫做以太网帧格式。 123arp -a? (192.168.79.1) at 00:50:56:c0:00:08 [ether] on eth1? (192.168.79.2) at 00:50:56:ec:ef:30 [ether] on eth1 ARP：解释局域网内的IP地址到网卡硬件地址的映射。通过ARP数据报表，来返回下一个路由器的MAC地址，封装数据。每到一个路由器，确认MAC地址并修改下一跳的MAC地址，再重新打包，再继续传。","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"https://github.com/casparthh/casparthh.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"高并发 - LVS的DR模型","slug":"lvs","date":"2020-03-01T08:53:16.000Z","updated":"2020-03-02T23:45:57.068Z","comments":true,"path":"2020/03/01/lvs/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/03/01/lvs/","excerpt":"理论基础网卡上有IP和MAC地址，网卡一加电就会将自己公布出去，别的机器只能知道IP地址逻辑的会走ARP协议请求MAC地址。Linux系统下 /proc 是虚拟目录，开机之后才会有的目录，里面放的内核及所有启动的进程，把里面的变量及参数抽象成文件，修改文件的值相当于改了内核变量参数的值，目录中的文件的参数值一变，内核立即发生效果。这些文件修改的时候不能用vi 命令去打开修改。因为会产生隐藏临时文件，只能echo 重定向去覆盖。 lo 回环接口，是内核上的虚拟网卡，虚拟网络接口，并非真实存在，并不真实地从外界接收和发送数据包，而是在系统内部接收和发送数据包，因此虚拟网络接口不需要驱动程序。lo回环地址 eth0 以太网接口，以太网接口与网卡对应，每个硬件网卡(一个MAC)对应一个以太网接口，其工作完全由网卡相应的驱动程序控制。如果物理网卡只有一个，而却有eth1，eth2等，则可能存在无线网卡或多个虚拟网卡，虚拟网卡由系统创建或通过应用层程序创建，作用与物理网卡类似。","text":"理论基础网卡上有IP和MAC地址，网卡一加电就会将自己公布出去，别的机器只能知道IP地址逻辑的会走ARP协议请求MAC地址。Linux系统下 /proc 是虚拟目录，开机之后才会有的目录，里面放的内核及所有启动的进程，把里面的变量及参数抽象成文件，修改文件的值相当于改了内核变量参数的值，目录中的文件的参数值一变，内核立即发生效果。这些文件修改的时候不能用vi 命令去打开修改。因为会产生隐藏临时文件，只能echo 重定向去覆盖。 lo 回环接口，是内核上的虚拟网卡，虚拟网络接口，并非真实存在，并不真实地从外界接收和发送数据包，而是在系统内部接收和发送数据包，因此虚拟网络接口不需要驱动程序。lo回环地址 eth0 以太网接口，以太网接口与网卡对应，每个硬件网卡(一个MAC)对应一个以太网接口，其工作完全由网卡相应的驱动程序控制。如果物理网卡只有一个，而却有eth1，eth2等，则可能存在无线网卡或多个虚拟网卡，虚拟网卡由系统创建或通过应用层程序创建，作用与物理网卡类似。 关闭arp解析，隐藏VIP方法/proc/sys/net/ipv4/conf/eth0 目录下有arp_ignore &amp; arp_announce 两个文件，默认设置都为0 arp_ingore: 定义接收到ARP请求时的响应级别 0: 只要本地配置的有相应地址，就给予响应； 1: 只有请求的目标（MAC）地址配置请求到达的接口上的时候，才给予响应； arp_announce: 定义将自己地址向外通告时的通告级别 0: 将本地任何地址的任何接口向外通告； 1: 试图只向目标网络参与其网络匹配的地址； 2: 仅向与本地接口上地址匹配的网络进行通知； 1)修改内核： 1234echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;eth0&#x2F;arp_ignore echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_ignore echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;eth0&#x2F;arp_announce echo 2 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;conf&#x2F;all&#x2F;arp_announce 2）设置隐藏的vip： 1ifconfig lo:3 192.168.79.110 netmask 255.255.255.255 LVS服务配置 安装lvs的管理工具ipvsadm1yum install ipvsadm -y 添加虚拟IP添加虚拟IP规则，管理集群服务ipvsadm -A -t 192.168.79.110:80 -s rr -A：添加虚拟IP规则-A -t|u|f service-address [-s scheduler]-t: TCP协议的集群-u: UDP协议的集群service-address: IP:PORT-f: FWM: 防火墙标记service-address: Mark Number修改：-E删除：-D -t|u|f service-addressscheduler 调度方法，one of rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq, the default scheduler is wlc. 添加服务在虚拟IP中添加服务规则，管理集群服务中的RSipvsadm -a -t 192.168.79.110:80 -r 192.168.79.102 -g -w 1ipvsadm -a -t 192.168.79.110:80 -r 192.168.79.103 -g -w 1 -a： 添加服务规则-t|u|f service-address -r server-address [-g|i|m] [-w weight]-t|u|f service-address：事先定义好的某集群服务-r server-address: 某RS的地址，在NAT模型中，可使用IP：PORT实现端口映射；[-g|i|m]: LVS类型-g: DR-i: TUN-m: NAT[-w weight]: 定义服务器权重修改：-e删除：-d -t|u|f service-address -r server-address 查看 -L|l-n: 数字格式显示主机地址和端口–stats：统计数据–rate: 速率–timeout: 显示tcp、tcpfin和udp的会话超时时长-:c 显示当前的ipvs连接状况ipvsadm -lnc 偷窥负载记录 删除所有集群服务 -C：清空ipvs规则 保存规则 -S:保存规则ipvsadm -S &gt; /path/to/somefile 载入规则 -R 载入此前的规则：ipvsadm -R &lt; /path/form/somefile 调度方法：rr: 轮询调度wrr: 加权轮询调度sh: 源地址散列调度Ulc: 最小连接调度wlc: 加权最小连接调度 (默认)sed: 最短期望延迟nq: 最少队列调度lblc: 基于本地的最少连接dh: 目标地址散列调度lblcr: 基于本地的带复制功能的最少连接","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"https://github.com/casparthh/casparthh.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"LVS","slug":"LVS","permalink":"https://github.com/casparthh/casparthh.github.io/tags/LVS/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"JVM - Class文件格式入门","slug":"classfile","date":"2020-02-22T08:30:57.000Z","updated":"2020-02-23T08:55:12.435Z","comments":true,"path":"2020/02/22/classfile/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/22/classfile/","excerpt":"JVM 是一种规范参考文档：https://docs.oracle.com/en/java/javase/13/https://docs.oracle.com/javase/specs/index.htmlhttps://docs.oracle.com/javase/specs/jvms/se13/html/index.html 虚构出来的一台计算机 -字节码指令集（汇编语言）-内存管理：堆、栈、方法区等 常见的JVM实现 Hotspot - Oracl 官方 Jrockit - BEA，曾经号称世界上最快的JVM,被Oracle收购后，合并于hotspot J9 - IBM Microsoft VM TaobaoVM - Hotspot 深度定制版 LiquidVM - 直接针对硬件 azul zing - 商业版，最新垃圾回收的业界标杆，参考zing的垃圾回收产生了ZGC JDK, JRE, JVM","text":"JVM 是一种规范参考文档：https://docs.oracle.com/en/java/javase/13/https://docs.oracle.com/javase/specs/index.htmlhttps://docs.oracle.com/javase/specs/jvms/se13/html/index.html 虚构出来的一台计算机 -字节码指令集（汇编语言）-内存管理：堆、栈、方法区等 常见的JVM实现 Hotspot - Oracl 官方 Jrockit - BEA，曾经号称世界上最快的JVM,被Oracle收购后，合并于hotspot J9 - IBM Microsoft VM TaobaoVM - Hotspot 深度定制版 LiquidVM - 直接针对硬件 azul zing - 商业版，最新垃圾回收的业界标杆，参考zing的垃圾回收产生了ZGC JDK, JRE, JVM 查看ByteCode的方法 javap JBE 可以直接修改 JClassLib IDEA插件之一 Class 文件构成 魔数 “cafebaby” Class 文件版本 常量池 访问标志 类索引，父类索引，接口索引集合 字段表集合 方法表集合 属性表集合 Class 文件格式 类型 名称 数量 U4 magic 1 U2 minor_version 1 U2 major_version 1 U2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 U2 access_flags 1 U2 this_class 1 U2 super_class 1 U2 interfaces_count 1 U2 interfaces interfaces_count U2 fields_count 1 field_info fields fields_count U2 methods_count 1 method_info methods methods_count U2 attributes_count 1 attribute_info attributes attributes_count u1 一个字节，u2 两个字节。。。一个16进制数就是4位，2个16进制数就是8位，也就是一个字节char 1 个字节int &amp; float 4个字节double &amp; long 8个字节magic = 0xCAFEBABE.minor_version, major_version 定义版本号constant_pool_count = constant_pool.size +1 access_flags参考 jvms13 Table 4.1-B. Class access and property modifiers Flag Name Value Interpretation ACC_PUBLIC 0x0001 Declared public; may be accessed from outside its package. ACC_FINAL 0x0010 Declared final; no subclasses allowed. ACC_SUPER 0x0020 Treat superclass methods specially when invoked by the invokespecial instruction. ACC_INTERFACE 0x0200 Is an interface, not a class. ACC_ABSTRACT 0x0400 Declared abstract; must not be instantiated. ACC_SYNTHETIC 0x1000 Declared synthetic; not present in the source code. ACC_ANNOTATION 0x2000 Declared as an annotation type. ACC_ENUM 0x4000 Declared as an enum type. ACC_MODULE 0x8000 Is a module, not a class or interface. *实际值采用的位运算 Field Descriptors参考 jvms13 Table 4.3-A. Interpretation of field descriptors FieldType term Type Interpretation B byte signed byte C char Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 D double double-precision floating-point value F float single-precision floating-point value I int integer J long long integer L ClassName; reference an instance of class ClassName S short signed short Z boolean true or false [ reference one array dimension Method Descriptors( {ParameterDescriptor} ) ReturnDescriptor Object m(int i, double d, Thread t) {…}int-&gt;I, double-&gt;D, Thread-&gt;Ljava/lang/Thread，返回值Ojbect-&gt;Ljava/lang/Object; 所以该方法的描述符为：(IDLjava/lang/Thread;)Ljava/lang/Object; 如果返回值为空，则ReturnDescriptor为VoidDescriptor-&gt;VThe character V indicates that the method returns no value (its result is void). Constant Pool常量池中的每一个entry必须是由一个字节的tag开始来表示该常量的种类。参考 jvms13 Table 4.4-A. Constant pool tags (by section) Constant Kind Tag Section CONSTANT_Utf8 1 §4.4.7 CONSTANT_Integer 3 §4.4.4 CONSTANT_Float 4 §4.4.4 CONSTANT_Long 5 §4.4.5 CONSTANT_Double 6 §4.4.5 CONSTANT_Class 7 §4.4.1 CONSTANT_String 8 §4.4.3 CONSTANT_Fieldref 9 §4.4.2 CONSTANT_Methodref 10 §4.4.2 CONSTANT_InterfaceMethodref 11 §4.4.2 CONSTANT_NameAndType 12 §4.4.6 CONSTANT_MethodHandle 15 §4.4.8 CONSTANT_MethodType 16 §4.4.9 CONSTANT_Dynamic (JDK11) 17 §4.4.10 CONSTANT_InvokeDynamic 18 §4.4.10 CONSTANT_Module (JDK9) 19 §4.4.11 CONSTANT_Package (JDK9) 20 §4.4.12 表中的section表是该tag详细文档对应的章节。 CONSTANT_Utf8_info12345CONSTANT_Utf8_info &#123; u1 tag; &#x2F;&#x2F;占一个字节, CONSTANT_Utf8 对就上面的值为1 u2 length; &#x2F;&#x2F;UTF-8字符串占用的字节数 u1 bytes[length]; &#x2F;&#x2F;长度为length的字符串&#125; CONSTANT_Integer_info, CONSTANT_Float_info Structures 数据结构123456789CONSTANT_Integer_info &#123; u1 tag; u4 bytes; &#125;CONSTANT_Float_info &#123; u1 tag; u4 bytes; &#125; CONSTANT_Long_info and CONSTANT_Double_info 数据结构12345678910CONSTANT_Long_info &#123; u1 tag; u4 high_bytes; u4 low_bytes;&#125;CONSTANT_Double_info &#123; u1 tag; u4 high_bytes; u4 low_bytes;&#125; CONSTANT_Class_info 数据结构1234CONSTANT_Class_info &#123; u1 tag; &#x2F;&#x2F;CONSTANT_Class 对应上面表中的7， 占一个字节； u2 name_index; &#x2F;&#x2F;指向常量池的索引位置，该位置存放类的名称, 占用2个字节&#125; CONSTANT_String_info 数据结构1234CONSTANT_String_info &#123; u1 tag; u2 string_index; &#x2F;&#x2F;占2字节，指向字符串的索引;&#125; CONSTANT_Fieldref_info, CONSTANT_Methodref_info, CONSTANT_InterfaceMethodref_info 内存节构123456789101112131415CONSTANT_Fieldref_info &#123; u1 tag; &#x2F;&#x2F;CONSTANT_Fieldref 对应上面表中的9， 占一个字节； u2 class_index; &#x2F;&#x2F;占2字节，指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项 u2 name_and_type_index; &#x2F;&#x2F;占2字节，指向字段描述符CONSTANT_NameAndType的索引项&#125;CONSTANT_Methodref_info &#123; u1 tag; &#x2F;&#x2F;CONSTANT_Methodref 对应上面表中的10， 占一个字节； u2 class_index; &#x2F;&#x2F;占2字节，指向声明方法的类或者接口描述符CONSTANT_Class_info的索引项 u2 name_and_type_index; &#x2F;&#x2F;占2字节，指向字段描述符CONSTANT_NameAndType的索引项&#125;CONSTANT_InterfaceMethodref_info &#123; u1 tag; &#x2F;&#x2F;CONSTANT_InterfaceMethodref 对应上面表中的11， 占一个字节； u2 class_index; &#x2F;&#x2F;占2字节，指向声明方法的类或者接口描述符CONSTANT_Class_info的索引项 u2 name_and_type_index; &#x2F;&#x2F;占2字节，指向字段描述符CONSTANT_NameAndType的索引项&#125; CONSTANT_NameAndType_info12345CONSTANT_NameAndType_info &#123; u1 tag; &#x2F;&#x2F;1字节，NameAndType 对就表中的值12 u2 name_index; &#x2F;&#x2F;2字节，指向该字段或方法名称常量项的索引 u2 descriptor_index; &#x2F;&#x2F;2字节，指向该字段或方法描述符常量项的索引&#125;","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://github.com/casparthh/casparthh.github.io/tags/JVM/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"JVM - GC和GC Tuning","slug":"GC","date":"2020-02-22T08:20:37.000Z","updated":"2020-03-03T07:04:49.266Z","comments":true,"path":"2020/02/22/GC/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/22/GC/","excerpt":"一、GC的基础知识什么是垃圾没有任何引用指向的一个对象或者多个对象（循环引用） 如何定位垃圾 引用计数（ReferenceCount） 根可达算法(RootSearching) 常见的垃圾回收算法 标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描） 拷贝算法 (copying) - 没有碎片，浪费空间 标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整）","text":"一、GC的基础知识什么是垃圾没有任何引用指向的一个对象或者多个对象（循环引用） 如何定位垃圾 引用计数（ReferenceCount） 根可达算法(RootSearching) 常见的垃圾回收算法 标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描） 拷贝算法 (copying) - 没有碎片，浪费空间 标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整） JVM内存分代模型（用于分代垃圾回收算法） 部分垃圾回收器使用的模型除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型G1是逻辑分代，物理不分代除此之外不仅逻辑分代，而且物理分代 新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace 永久代 元数据 - Class 永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存） 字符串常量 1.7 - 永久代，1.8 - 堆 MethodArea逻辑概念 - 永久代、元数据 新生代 = Eden + 2个suvivor区 YGC回收之后，大多数的对象会被回收，活着的进入s0 再次YGC，活着的对象eden + s0 -&gt; s1 再次YGC，eden + s1 -&gt; s0 年龄足够 -&gt; 老年代 （-XX:MaxTenuringThreshold=X X默认是15） s区装不下 -&gt; 老年代 老年代 顽固分子 老年代满了FGC Full GC 内存分配担保，在JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，然后新生代腾出来的空间用于为分配给最新的对象。 GC Tuning (Generation) 尽量减少FGC MinorGC = YGC MajorGC = FGC 二、垃圾回收器及调优常见的垃圾回收器 JDK诞生 Serial追随，为提高效率，诞生了PS，为了配合CMS，诞生了PN，CMS是1.4版本后期引入，CMS是里程碑式的GC，它开启了并发回收的过程，并发垃圾回收是因为无法忍受STW。 Serial：适用年轻代，串行回收 PS(Parallel Scavenge) 适用年轻代，并行回收 ParNew 适用年轻代，配合CMS的并行回收 SerialOld 适用老年代 ParallelOld 适用老年代，配合PS使用 CMS(ConcurrentMarkSweep) 老年代,并发的，垃圾回收和应用程序同时运行，降低STW(Stop The World)的时间(200ms)CMS问题比较多，所以现在没有一个版本默认是CMS，只能手工指定CMS既然是MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS的老年代分配对象分配不下的时候，使用SerialOld 进行老年代回收算法：三色标记 + Incremental Update工作过程：初始标记，并发标记，重新标记，并发清理优点：并发收集，低停顿缺点：占用大量的CPU，无法处理浮动垃圾，出现Concurrent Mode Failure，空间碎片 G1(10ms)算法：三色标记 + SATB (snapshot-at-the-beginning)优势：并行与并发，分代收集，空间整合，可预测的停顿步骤：初使标记，并发标记，最终标记，筛选回收 ZGC (1ms)算法：ColoredPointers + LoadBarrier Shenandoah算法：ColoredPointers + WriteBarrier PS 和 PN区别的延伸阅读：▪https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html 垃圾收集器跟内存大小的关系 Serial 几十兆 PS 上百兆 - 几个G CMS - 20G G1 - 上百G ZGC - 4T - 16T（JDK13） 1.8默认的垃圾回收：PS + ParallelOld 常见垃圾回收器组合参数设定：(1.8) -XX:+UseSerialGC = Serial New (DefNew) + Serial Old 小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器 -XX:+UseParNewGC = ParNew + SerialOld 这个组合已经很少用（在某些版本中已经废弃） -XX:+UseConcurrentMarkSweepGC = ParNew + CMS + Serial Old -XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】 -XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old -XX:+UseG1GC = G1 JVM调优第一步，了解JVM常用命令行参数 JVM的命令行参数参考：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html HotSpot参数分类 标准： - 开头，所有的HotSpot都支持 非标准：-X 开头，特定版本HotSpot支持特定命令 不稳定：-XX 开头，下个版本可能取消 java -X 区分概念：内存泄漏memory leak，内存溢出out of memory java -XX:+PrintCommandLineFlags -version 观查虚拟机配置 java -XX:+PrintFlagsInitial 默认参数值 java -XX:+PrintFlagsFinal 最终参数值 java -XX:+PrintFlagsFinal | grep xxx 找到对应的参数 java -XX:+PrintFlagsFinal -version |grep GC 调优前的基础概念： 吞吐量：吞吐量（CPU用于运行用户代码的时间与CPU消耗的总时间的比值）用户代码时间 /（用户代码执行时间 + 垃圾回收时间） 响应时间：STW越短，响应时间越好 所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量… 问题：科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO）响应时间：网站 GUI API （1.8 G1） 什么是调优？ 根据需求进行JVM规划和预调优 优化运行JVM运行环境（慢，卡顿） 解决JVM运行过程中出现的各种问题(OOM) 调优，从规划开始 调优，从业务场景开始，没有业务场景的调优都是耍流氓 无监控（压力测试，能看到结果），不调优 步骤： 熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器） 响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应） 吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS] 选择回收器组合 计算内存需求（经验值） 选定CPU（越高越好） 设定年代大小、升级年龄 设定日志参数 -Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause 或者每天产生一个日志文件 观察日志情况 解决JVM运行中的问题 top命令观察问题：内存 &amp; CPU 占用率。 top -Hp 观察进程中的线程，哪个线程CPU和内存占比高 jps(java process status) 参数 -mlv 定位具体java进程jstack 定位线程状况，重点关注：WAITING BLOCKEDeg.waiting on &lt;0x0000000088ca3310&gt; (a java.lang.Object)假如有一个进程中100个线程，很多线程都在waiting on ，一定要找到是哪个线程持有这把锁怎么找？搜索jstack dump的信息，找 ，看哪个线程持有这把锁RUNNABLE 为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称怎么样自定义线程池里的线程名称？（自定义ThreadFactory） jinfo pidjinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。 jstat -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler（最好用）jstat -gc|gcnew|gcold|gcutil pid 500 10 : 每个500个毫秒打印GC的情况，共打印10次退出jstat -class pid 观察加载类的数量jstat -options 查看所有options jmap 一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。jmap -heap pid 打印heap的概要信息，GC使用的算法，heap（堆）的配置及JVM堆内存的使用情况.jmap -histo pid | head -200， 将实例对象最多的200个类jmap -histo:live pid 在*:live前会进行full gc，带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小jmap -dump:format=b,file=xxx pid -dump 使用hprof二进制形式,输出jvm的heap内容到文件=. live子选项是可选的，假如指定live选项,那么只输出活的对象到文件 线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿，线上慎用（电商不适合用） 1：-XX:+HeapDumpOnOutOfMemoryError 设定了参数HeapDump，OOM的时候会自动产生堆转储文件 2：很多服务器备份（高可用），停掉这台服务器对其他服务器不影响 3：用在线定位 使用MAT / jhat /jvisualvm 进行dump文件分析 Jhat参考资料：https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html Arthas在线排查工具 为什么需要在线排查？ 在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。 观察jvm信息 thread定位线程问题 dashboard 观察系统情况 heapdump + jhat分析 jad反编译 动态代理生成类的问题定位 第三方的类（观察代码） 版本问题（确定自己最新提交的版本是不是被使用） redefine 热替换 目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性 sc - search class watch - watch method 三、常用参数GC算法的基础概念 Card Table由于做YGC时，需要扫描整个OLD区，效率非常低，所以JVM设计了CardTable， 如果一个OLD区CardTable中有对象指向Y区，就将它设为Dirty，下次扫描时，只需要扫描Dirty Card在结构上，Card Table用BitMap来实现 GC常用参数 -Xmn -Xms -Xmx -Xss年轻代 最小堆 最大堆 栈空间 -XX:+UseTLAB使用TLAB(Thread Local Allocation Buffer)，默认打开 -XX:+PrintTLAB打印TLAB的使用情况 -XX:TLABSize设置TLAB大小 -XX:+DisableExplictGCSystem.gc()不管用 ，FGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationConcurrentTime (低) 打印应用程序时间 -XX:+PrintGCApplicationStoppedTime （低） 打印暂停时长 -XX:+PrintReferenceGC （重要性低）记录回收了多少种不同引用类型的引用 -verbose:class 类加载详细过程 -XX:+PrintVMOptions -XX:+PrintFlagsFinal -XX:+PrintFlagsInitial 必须会用 -Xloggc:/opt/log/gc.log -XX:MaxTenuringThreshold 升代年龄，最大值15 -XX:PretenureSizeThreshold=1M //大对象直接存入老年代,默认值是0，意思是不管多大都是先在eden中分配内存 锁自旋次数 -XX:PreBlockSpin 热点代码检测参数-XX:CompileThreshold 逃逸分析 标量替换 这些不建议设置 Parallel常用参数 -XX:SurvivorRatio -XX:+ParallelGCThreads 并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同 -XX:+UseAdaptiveSizePolicy 自动选择各区大小比例 CMS常用参数 -XX:+UseConcMarkSweepGC -XX:ParallelCMSThreads CMS线程数量 -XX:CMSInitiatingOccupancyFraction使用多少比例的老年代后开始CMS收集，默认是68%(近似值)，如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收） -XX:+UseCMSCompactAtFullCollection在FGC时进行压缩 -XX:CMSFullGCsBeforeCompaction多少次FGC之后进行压缩 -XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingPermOccupancyFraction达到什么比例时进行Perm回收 GCTimeRatio设置GC时间占用程序运行时间的百分比 -XX:MaxGCPauseMillis停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代 -XX:LargePageSizeInBytes=64m 内存分页 G1常用参数 -XX:+UseG1GC -XX:MaxGCPauseMillis建议值，G1会尝试调整Young区的块数来达到这个值 -XX:GCPauseIntervalMillis设置停顿间隔时间 -XX:+G1HeapRegionSize分区大小，建议逐渐增大该值，1 2 4 8 16 32。随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长ZGC做了改进（动态区块大小） G1NewSizePercent新生代最小比例，默认为5% G1MaxNewSizePercent新生代最大比例，默认为60% GCTimeRatioGC时间建议比例，G1会根据这个值调整堆空间 ConcGCThreads线程数量 InitiatingHeapOccupancyPercent启动G1的堆空间占用比例 四、参考资料 https://docs.oracle.com/en/java/javase/13/ https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp JVM调优参考文档：https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184 https://www.oracle.com/technical-resources/articles/java/g1gc.html Arthas：https://github.com/alibaba/arthas 启动arthas java -jar arthas-boot.jar 绑定java进程 dashboard命令观察系统整体情况 help 查看帮助 help xx 查看具体命令帮助","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://github.com/casparthh/casparthh.github.io/tags/JVM/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"JVM - JMM内存模型","slug":"jmm","date":"2020-02-22T08:20:37.000Z","updated":"2020-02-23T08:38:35.808Z","comments":true,"path":"2020/02/22/jmm/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/22/jmm/","excerpt":"一、CPU和内存的交互在计算机中，CPU和内存的交互最为频繁，相比内存，磁盘读写太慢，内存相当于高速的缓冲区。 在多核CPU中，每个处理器都有各自的高速缓存(L1,L2,L3)，而主内存确只有一个 。 越靠近CPU的缓存越快也越小。所以L1缓存(一级缓存)很小但很快，并且紧靠着在使用它的CPU内核。L2大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。 当CPU执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。","text":"一、CPU和内存的交互在计算机中，CPU和内存的交互最为频繁，相比内存，磁盘读写太慢，内存相当于高速的缓冲区。 在多核CPU中，每个处理器都有各自的高速缓存(L1,L2,L3)，而主内存确只有一个 。 越靠近CPU的缓存越快也越小。所以L1缓存(一级缓存)很小但很快，并且紧靠着在使用它的CPU内核。L2大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。 当CPU执行运算的时候，它先去L1查找所需的数据，再去L2，然后是L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。 从CPU到 大约需要的CPU 周期 大约需要的时间 主存 约60-80纳秒 QPI总线传输(between sockets, not drawn) 约20ns L3 cache 约40-45 cycles 约15ns L2 cache 约10 cycles 约3ns L1 cache 约3-4 cycles 约1ns 寄存器 1 cycle 二、缓存行数据在缓存中不是以独立的项来存储的，缓存是由缓存行组成的，通常是64字节，并且它有效地引用主内存中的一块地址。一个Java的long类型是8字节，因此在一个缓存行中可以存8个long类型的变量。非常奇妙的是如果你访问一个long数组，当数组中的一个值被加载到缓存中，它会额外加载另外7个。因此你能非常快地遍历这个数组。因此如果数据结构中的项在内存中不是彼此相邻的（链表），你将得不到免费缓存加载所带来的优势。并且在这些数据结构中的每一个项都可能会出现缓存未命中。 伪共享问题 （缓存行对齐提高效率）但这种加载有一个弊端。设想long类型的数据不是数组的一部分，它只是一个单独的变量。让我们称它为head。然后再设想有另一个变量tail紧挨着它。当加载head到缓存的时候同时也加载了tail。tail正在被你的生产者写入，而head正在被你的消费者写入。这两个变量实际上并不是密切相关的，而事实上却要被两个不同内核中运行的线程所使用。 设想消费者更新了head的值。缓存中的值和内存中的值都被更新了，而其他所有存储head的缓存行都会都会失效。请记住我们必须以整个缓存行作为单位来处理，不能只把head标记为无效。现在如果一些正在其他内核中运行的进程只是想读tail的值，整个缓存行需要从主内存重新读取。那么一个和你的消费者无关的线程读一个和head无关的值，它被缓存未命中给拖慢了。 硬件层数据一致性MESI(Modified Exclusive Shared Or Invalid)–CPU缓存一致性协议, 是一种广泛使用的支持写回策略的缓存一致性协议。 MESI协议中的状态CPU中每个缓存行（caceh line)使用4种状态进行标记，CPU在每个cache line 额外两位标记四种状态（使用额外的两位(bit)表示): M: 被修改（Modified)该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。 当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。 E: 独享的（Exclusive)该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。 S:共享的（Shared)该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。 I: 无效的（Invalid）该缓存是无效的（可能有其它CPU修改了该缓存行）。 三、乱序问题CPU为了提高指令执行效率，会在一条指令执行过程中（比如去内存读数据（慢100倍）），去同时执行另一条指令，前提是，两条指令没有依赖关系。 内存屏障(Memory Barrier) 保证特定情况下不乱序CPU执行指令可能是无序的，内存屏障有两个比较重要的作用 阻止屏障两侧指令重排序 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。 硬件内存屏障 X86 sfence: store| 在sfence指令前的写操作当必须在sfence指令后的写操作前完成。 lfence：load | 在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 mfence：modify/mix | 在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。 原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序 JVM级别如何规范（JSR133） LoadLoad屏障：在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。 StoreStore屏障：在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。 LoadStore屏障：在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。 StoreLoad屏障：在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。 volatile的实现细节 字节码层面 ACC_VOLATILE JVM层面, Volatile内存区的读写都加屏障 StoreStoreBarrier volatile 写操作 StoreLoadBarrier LoadLoadBarrier volatile 读操作 LoadStoreBarrier synchronized实现细节 字节码层面 ACC_SYNCHRONIZED monitorenter monitorexit JVM层面 C C++ 调用了操作系统提供的同步机制","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://github.com/casparthh/casparthh.github.io/tags/JVM/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"JVM - 类加载 & 初始化","slug":"ClassLoader","date":"2020-02-22T06:22:56.000Z","updated":"2020-02-23T08:47:14.978Z","comments":true,"path":"2020/02/22/ClassLoader/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/22/ClassLoader/","excerpt":"","text":"","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://github.com/casparthh/casparthh.github.io/tags/JVM/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"多线程 - Java容器","slug":"container","date":"2020-02-16T14:05:29.000Z","updated":"2020-03-02T23:44:38.593Z","comments":true,"path":"2020/02/16/container/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/16/container/","excerpt":"Java 容器容器 分两大类Collection、Map，Collection又分三大类List、Set、Queue队列 SetSet 与 List, Queue 的主要区别是不会有重复元素 ArrayList &amp; LinkedList 没有加锁，线程不安全。 ArrayList是基于数组实现的，LinkedList是基于双链表实现的。 LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向对列。 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。","text":"Java 容器容器 分两大类Collection、Map，Collection又分三大类List、Set、Queue队列 SetSet 与 List, Queue 的主要区别是不会有重复元素 ArrayList &amp; LinkedList 没有加锁，线程不安全。 ArrayList是基于数组实现的，LinkedList是基于双链表实现的。 LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向对列。 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。 Queue Queue 实现的实际上是一个队列，有进有出，它实现了很多对线程友好的API offer、peek、poll，他的一个子类型叫 BlockingQueue对线程友好的API又添加了put和take，这两个实现了阻塞操作，这个是在其他的List、 Set里面都是没有的。这里面最重要的就是是叫做阻塞队列，它的实现的初衷就是为了线程池、高并发做准备的。 Queue里面还有一个子接口叫Deque叫双端队列，一般的队列只是从一端往里扔从另一端往外取。 Deque就是说你可以从反方向装从另外一个方向取。 Queue Method Equivalent Deque Method 说明 add(e) addLast(e) 向队尾插入元素，失败则抛出异常 offer(e) offerLast(e) 向队尾插入元素，失败则返回false remove(e) removeFirst(e) 获取并删除首元素，失败则抛出异常 poll(e) pollFirst(e) 获取并删除首元素，失败则返回null element(e) getFirst(e) 获取但不删除首元素，失败则抛出异常 peek(e) peekFirst(e) 获取但不删除首元素，失败则返回null Vector &amp; HashTable最开始java1.0容器里只有两个，第一个叫Vector可以单独的往里扔，还有一个是Hashtable是可以一对一对往里扔的。Vector相对于实现了List接口，Hashtable实现了Map接口，Vector 和 Hashtable 自带锁所以性能低。 HashMapHashMap没有锁，线程不安全,他虽然速度比较快，但是多线程时数据会出问题。 Collections.synchronizedHashMapMap&lt;String,String&gt; map = Collections.synchronizedMap(new HashMap&lt;String,String&gt;());用的是SynchronizedMap这个方法，给HashMap我们手动加锁，它的源码自己做了一个Object，然后每次都是SynchronizedObject，严格来讲他和那个Hashtable效率上区别不大。 ConcurrentMap 接口ConcurrentHashMap &amp; ConcurrentSkipListMapConcurrentHashMap是多线程里面真正用的，提高效率主要提高在读上面，由于它往里插的时候内部又做了各种各样的判断，本来是链表的，到8之后又变成了红黑树，然后里面又做了各种各样的 CAS 的判断，所以他往里插的速度是要更低一些的。ConcurrentSkipListMap 通过跳表来实现的高并发容器并且这个Map是有排序的;这两个的区别一个是有序的一个是无序的，同时都支持并发的操作 CopyOnWriteCopyOnWriteArrayList &amp; CopyOnWriteArraySet &amp; CopyOnWriteMap写时复制，当Write的时候我们要进行复制。这个原码非常简单，当我们需要往里面加元素的时候，把里面的元素得复制出来，再添加一个位置存放新元素。 而且在写的时个有加锁，但在读的时候没有锁。在写的时候特别少，读的时候很多的情况下，在这个时候就可以考虑CopyOnWrite这种方式来提高效率。 1234567891011121314151617181920212223&#x2F;&#x2F;CopyOnWriteMap.put方法public V put(K key, V value) &#123; synchronized(this) &#123; Map&lt;K, V&gt; newMap &#x3D; new HashMap(this.internalMap); V val &#x3D; newMap.put(key, value); this.internalMap &#x3D; newMap; return val; &#125;&#125;&#x2F;&#x2F;CopyOnWriteArrayList.addpublic boolean add(E e) &#123; synchronized (lock) &#123; Object[] es &#x3D; getArray(); int len &#x3D; es.length; es &#x3D; Arrays.copyOf(es, len + 1); es[len] &#x3D; e; setArray(es); return true; &#125;&#125;&#x2F;&#x2F;CopyOnWriteArraySet 中实际是由CopyOnWriteArrayList存放的，在add的时候直接调用的CopyOnWriteArrayList.addIfAbsent(...) BlockingQueue 接口BlockingQueue的概念重点是在Blocking上，Blocking阻塞，Queue队列，是阻塞队列。BlockingQueue在 Queue的基础上又添加了两个方法，这两个方法一个叫put，一个叫take。这两个方法是真真正正的实现了阻塞。put往里装如果满了的话我这个线程会阻塞住，take往外取如果空了的话线程会阻塞住。所 以这个BlockingQueue就实现了生产者消费者里面的那个容器。 LinkedBlockingQueue用链表实现的BlockingQueue，是一个无界队列 ArrayBlockingqueueArrayBlockingQueue是有界的，可以指定它一个固定的值10，它容器就是10，那么当你往里面扔容器的时候，一旦他满了这个put方法就会阻塞住。然后你可以看看用add方法满了之后他会报异常。 offer用返回值来判断到底加没加成功，offer还有另外一个写法你可以指定一个时间尝试着往里面加1秒钟，1秒钟之后如果加不进去它就返回了. DelayQueueDelayQueue可以实现在时间上的排序，这个DelayQueue能实现按照在里面等待的时间来进行排序。 SynchronousQueueSynchronousQueue容量为0，就是这个东西它不是用来装内容的，SynchronousQueue是专门用来两 个线程之间传内容的，给线程下达任务。这个Queue和其他的很重要的区别就是 你不能往里头装东西，只能用来阻塞式的put调用，要求是前面得有人等着拿这个东西的时候你才可以 往里装，但容量为0，其实说白了就是我要递到另外一个的手里才可以。 TransferQueueTransferQueue传递，实际上是前面这各种各样Queue的一个组合，它可以给线程来传递任务，以此同时不像是SynchronousQueue只能传递一个，TransferQueue做成列表可以传好多个。比较牛X的是它添加了一个方法叫transfer，如果我们用put就相当于一个线程来了往里一装它就走了。transfer就是装完在这等着，阻塞等有人把它取走我这个线程才回去干我自己的事情。一般使用场景:是我做了一件事情，我这个事情要求有一个结果，有了这个结果之后我可以继续进行我下面的这个事情的时候，比方说 我付了钱，这个订单我付账完成了，但是我一直要等这个付账的结果完成才可以给客户反馈。 PriorityQueuePriorityQueue特点是它内部你往里装的时候并不是按顺序往里装的，而是内部进行了一个排序。","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Thread/"},{"name":"容器","slug":"容器","permalink":"https://github.com/casparthh/casparthh.github.io/tags/%E5%AE%B9%E5%99%A8/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"多线程 - 线程","slug":"thread","date":"2020-02-16T14:05:29.000Z","updated":"2020-03-02T23:44:53.201Z","comments":true,"path":"2020/02/16/thread/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/16/thread/","excerpt":"线程: 作为一个进程里面最小的执行单元它就叫一个线程，用简单的话讲一个程序里不同的执行路径就叫做一个线程 一、创建线程的几种方式： 继承Thread，并重写该类的run方法","text":"线程: 作为一个进程里面最小的执行单元它就叫一个线程，用简单的话讲一个程序里不同的执行路径就叫做一个线程 一、创建线程的几种方式： 继承Thread，并重写该类的run方法 1234567891011121314public class MyThread extends Thread&#123; @Override public void run()&#123; System.out.println(Thread.currentThread().getName()+\" 是继承写法。\"); &#125; public static void main(String[] args)&#123; MyThread thread = new MyThread(); thread.setName(\"extends thread\"); thread.start(); &#125;&#125; 通过Runnable接口创建线程类,创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 12345678910111213public class MyThread implements Runnable &#123; @Override public void run()&#123; System.out.println(Thread.currentThread().getName()+\" 写法。\"); &#125; public static void main(String[] args)&#123; Thread t = new Thread(new MyThread(),\"implements Runnable\"); t.start(); &#125;&#125; 通过Callable和Future创建线程 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值123456789101112131415161718192021public class MyCallableThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call()&#123; System.out.println(Thread.currentThread().getName()+\" 写法。\"); return 1; &#125; public static void main(String[] args)&#123; FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new MyCallableThread()); new Thread(task,\"implements Callable\").start(); try &#123; System.out.println(\"有返回值：\" + task.get()); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; catch (ExecutionException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 二、线程操作的几个方法 start: 启动一个新的线程,start方法必须子线程第一个调用的方法，start不能够重复调用，新线程会调用runnable接口提供的run方法 run: run方法是子线程的执行体，子线程从进入run方法开始直至run方法执行接收意味着子线程的任务执行接收， 在主线程直接调用run方法是不能创建子线程，只是普通方法调用 sleep: 睡眠，当前线程暂停一段时间让给别的线程去运行。Sleep是怎么复活由睡眠时间而定，等睡眠到规定的时间自动复活. Yield: 就是当前线程正在执行的时候停止下来进入等待队列，回到等待队列里在系统的调度算法里头，还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管 join: 意思就是在自己当前线程加入你调用Join的线程()，本线程等待。等调用的线程运行完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运行完毕继续t1运行(自己join自己没有意义) wait() 和 notify() 方法说明几点： 调用notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。 除了notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。 wait()法需要释放锁，所以必须在synchronized中使用，否则会抛出异常 IllegalMonitorStateException notify()方法也必须在synchronized中使用，并且应该指定对象 synchronized()、wait()、notify()对象必须一致，一个synchronized()代码块中只能有一个线程调 三、线程六种状态 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 阻塞(BLOCKED)：表示线程阻塞于锁。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 终止(TERMINATED)：表示该线程已经执行完毕。 *线程什么状态时候会被挂起?挂起是否也是一个状态?Running的时候，在一个cpu上会跑很多个线程，cpu会隔一段时间执行这个线程一下，在隔一段时间执行那个线程一下，这个是cpu内部的一个调度，从running扔回去就叫线程被挂起。 四、synchronized多个线程去访问同一个资源的时候对这个资源上锁 synchronized 使用方法和特性 在同步代码外嵌套synchronized(Object/Class) synchronized方法和synchronized(this)执行这段代码它是等值的 每次都定义个一个锁的对象Object o 把它new出来，那加锁的时候太麻烦每次都要new一个新的对象出来，所以呢，有一个简单的方式就是 synchronized(this)锁定当前对象就行 静态方法static是没有this对象的，你不需要new出一个对象来就能执行这个方法，但如果这个这个上面加一个synchronized的话就代表synchronized(T.class)。这里这个synchronized(T.class)锁的就是T类的对象 类锁和对象锁互不干扰，只有当监视的是同一个class（Class对象）的锁或同一个对象实例的锁才发生互斥 可重入，一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁 程序在执行过程中，如果出现异常，默认情况锁会被释放所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适， * 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。因此要非常小心的处理同步业务逻辑中的异常 如果锁的是new出来的对象，在某一种特定的不小心的情况下你把o变成了别的对象了，这个时候线程的并发就会出问题。锁是在对象的头上两位来作为代表的，你这线程本来大家都去访问这两位了，结果突然把 这把锁变成别的对象，去访问别的对象的两位了，这俩之间就没有任何关系了。因此，以对象作为锁的 时候不让它发生改变，加final。 五、锁升级的概念原来要去找操作系统，要找内核去申请这把锁，到后期做了对 synchronized的一些改进，他的效率比原来要改变了不少，改进的地方。当我们使用synchronized的 时候HotSpot的实现是这样的:上来之后第一个去访问某把锁的线程 比如sync (Object) ，来了之后先在 这个Object的头上面markword记录这个线程。(如果只有第一个线程访问的时候实际上是没有给这个 Object加锁的，在内部实现的时候，只是记录这个线程的ID(偏向锁))。偏向锁如果有线程争用的话，就升级为自旋锁，概念就是(有一个哥们儿在蹲马桶 ，另外来了一个哥 们，他就在旁边儿等着，他不会跑到cpu的就绪队列里去，而就在这等着占用cpu，用一个while的循环 在这儿转圈玩儿， 很多圈之后不行的话就再一次进行升级)。自旋锁转圈十次之后，升级为重量级锁，重量级锁就是去操作系统那里去申请资源。这是一个锁升级的过程。 六、volatile使一个变量在多个线程中可见，保证线程的可见性，同时防止指令重排序。线程可见性在CPU的级别是用缓存一直性来保 证的;禁止指令重排序CPU级别是你禁止不了的，那是人家内部运行的过程，提高效率的。但是在 虚拟机级别你家volatile之后呢，这个指令重排序就可以禁止。严格来讲，还要去深究它的内部的 话，它是加了读屏障和写屏障，这个是CPU的一个原语。A B线程都用到一个变量，java默认是A线程中保留一份copy,这样如果B线程修改了该变量，则A线程未必知道，使用volatile关键字，会让所有线程都会读到变量的修改值并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized 七、CAS 比较和交换（Conmpare And Swap)它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。 原子性保证新值基于最新信息计算; 如果该值在同一时间被另一个线程更新，则写入将失败。凡是以Atomic开头的都是用CAS这种操作来保证线程安全的这么一些个类。AtomicInteger的意思就是里面包了一个Int类型，这个int类型的自增 count++ 是线程安全的，还有拿值等等是线程安全的，由于我们在工作开发中经常性的有那种需求，一个值所有的线程共同访问它往 上递增 ，所以jdk专门提供了这样的一些类。它的内部调用，就会跑到Unsafe类去(不安全的)，Unsafe中对CAS的实现是C++写的。也就是说AtomicInteger它的内部是调用了 Unsafe这个类里面的方法CompareAndSetI(CAS)。这个比较并且设定的意思是什么呢，我原来想改变某一个值0 ，我想把它变成1，但是其中我想做到线程安全，就只能加锁synchronized ，不然线程就不安全。我现在可以用另外一种操作来替代这把锁，就是cas操作，你可以把它想象成一个方法，这个方法有三个参数，cas(V，Expected，NewValue)。V第一个参数是要改的那个值;Expected第二个参数是期望当前的这个值会是几;NewValue要设定的新值。当前这个线程想改这个值的时候我期望你这值就是0，你不能是个1，如果是1就说明我这值不对，然后想把你变成1。当你判断的时候，发现是我期望的值，还没有进行新值设定的时候值发生了改变怎么办，cas是cpu的原语支持，也就是说cas操作是cpu指令级别上的支持，中间不能被打断。 ABA问题：假如说你有一个值，我拿到这个值是1，想把它变成2，我拿到1用cas操作，期望值是1，准备变成2，这个对象Object，在这个过程中，没有一个线程改过我肯定是可以更改的，但是 如果有一个线程先把这个1变成了2后来又变回1，中间值更改过，它不会影响我这个cas下面操作，这就是ABA问题。 这种问题怎么解决。如果是int类型的，最终值是你期望的，也没有关系，这种没关系可以不去管这个问题。如果你确实想管这个问题可以加版本号，做任何一个值的修改，修改完之后加一，后面检查的时候连带版本号一起检查。 八、Atomic 类AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的多线程对一个数进行递增方法: 一个long类型的数，递增的时候我们加锁; 使用AtomicLong可以让它不断的往上递增; LongAdder;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Incrementer &#123; static Long counter1 = new Long(0L); static AtomicLong counter2 = new AtomicLong(0L); static LongAdder counter3 = new LongAdder(); final static Object o = new Object(); public static void main(String[] args) &#123; //synchronized for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 100; j++) &#123; synchronized (o) &#123; //去掉锁之后结果就有问题 counter1= counter1+1; &#125; &#125; &#125;).start(); &#125; //AtomicLong for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 100; j++) &#123; counter2.incrementAndGet(); &#125; &#125;).start(); &#125; //LongAdder for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 100; j++) &#123; counter3.increment(); &#125; &#125;).start(); &#125; try &#123; //简单处理，休眠主线程等上面的计算线程完成。 TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(counter1); System.out.println(counter2); System.out.println(counter3); &#125;&#125; 九、基于CAS的一些新类型的锁1. RenentrantLock 可重入锁 ReentrantLock是可以替代synchronized的, 需要手动枷锁，手动解锁、可以出现多个不同的等待队列 ReentrantLock有一些功能还是要比synchronized强大的，强大的地方，你可以使用tryLock进行尝试 锁定，不管锁定与否，方法都将继续执行，synchronized如果搞不定的话他肯定就阻塞了，但是用 ReentrantLock你自己就可以决定你到底要不要wait。 原来写synchronized的地方换 写lock.lock()，加完锁之后需要注意的是记得lock.unlock()解锁，由于synchronized是自动解锁的，大括号执行完就结束了。lock就不行，lock必须得手动解锁，手动解锁一定要写在try…finally里面保证最好一定要解锁，不然的话上锁之后中间执行的过程有问题了，死在那了，别人就永远也拿不到这把锁了。 ReentrantLock还可以用lock.lockInterruptibly()这个类，对interrupt()方法做出相应，可以被打断的加锁，如果以这种方式加锁的话我们可以调用一个t2.interrupt(); 打断线程2的等待。 ReentrantLock还可以指定为公平锁，公平锁的意思是当我们new一个ReentrantLock你可以传一个参数为true，这个true表示公平锁，公平锁的意思是谁等在前面就先让谁执行，而不是说谁后来了之后就马上让谁执行。如果说这个锁不公平，来了一个线程上来就抢，它是有可能先抢到的。（是否公平锁分别有NonfairSync &amp; FairSync 两个不同的实现） 除了synchronized之外，多数内部都是用的cas。AQS的实际上它内部用的是 park和unpark，也不是全都用的cas,他还是做了一个锁升级的概念，只不过这个锁升级做的比较隐秘， 在等待这个队列的时候如果你拿不到还是进入一个阻塞的状态，前面至少有一个cas的状态，他不像原先就直接进入阻塞状态了。（参考后面的源码阅读部分） 1234567891011121314151617181920212223242526272829public class ReentrantLockTest &#123; static Integer i = new Integer(0); static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) &#123; for (int j = 0; j &lt; 10000; j++) &#123; new Thread(() -&gt; &#123; for (int k = 0; k &lt; 100 ; k++) &#123; lock.lock(); try &#123; i++; &#125; finally &#123; // 必须要必须要必须要手动释放锁,必须要必须要必须要手动释放锁,必须要必须要必须要手动释放锁(重要的事情说三遍) // 使用syn锁定的话如果遇到异常，jvm会手动释放锁，但是lock必须手动释放锁 lock.unlock(); &#125; &#125; &#125;).start(); &#125; try &#123; //简单处理，休眠主线程等上面的计算线程完成。 TimeUnit.SECONDS.sleep(5); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(i); &#125;&#125; ReentrantLock 非公平锁原码阅读 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 ReentrantLock lock &#x3D; new ReentrantLock(); lock.lock(); &#x2F;&#x2F;从断点跟踪 public void lock() &#123; sync.acquire(1); &#125; public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; final boolean nonfairTryAcquire(int acquires) &#123; final Thread current &#x3D; Thread.currentThread(); int c &#x3D; getState(); &#x2F;&#x2F;the current value of synchronization state. if (c &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;如果当前对象没有锁，直接设置一个排它锁 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123; &#x2F;&#x2F; 如果当前持有锁的是同一个线程，则设置为可重入 int nextc &#x3D; c + acquires; if (nextc &lt; 0) &#x2F;&#x2F; overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#x2F;&#x2F;没拿到锁，返回fallse &#125; private Node addWaiter(Node mode) &#123; &#x2F;&#x2F;mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared, &#x2F;&#x2F;now 一个共享锁或排它锁节点 Node node &#x3D; new Node(mode); &#x2F;&#x2F;取出队列中最后一个节点，设置为该新节点的上一个节点。并返回新节点。 &#x2F;&#x2F;如果最后一个节点为空，初使化一个同步队列 for (;;) &#123; Node oldTail &#x3D; tail; if (oldTail !&#x3D; null) &#123; node.setPrevRelaxed(oldTail); if (compareAndSetTail(oldTail, node)) &#123; oldTail.next &#x3D; node; return node; &#125; &#125; else &#123; initializeSyncQueue(); &#125; &#125;&#125;final boolean acquireQueued(final Node node, int arg) &#123; boolean interrupted &#x3D; false; try &#123; for (;;) &#123; final Node p &#x3D; node.predecessor(); &#x2F;&#x2F;取出前面新new 节点，判断上一个节点，是不是头部节点，如果是的话，直接再次尝试拿锁。 &#x2F;&#x2F;如果拿锁成功，那新节点，就是头部节点 if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next &#x3D; null; &#x2F;&#x2F; help GC return interrupted; &#125; &#x2F;&#x2F;判断是否继续自旋拿锁，还是park if (shouldParkAfterFailedAcquire(p, node)) interrupted |&#x3D; parkAndCheckInterrupt(); &#125; &#125; catch (Throwable t) &#123; cancelAcquire(node); if (interrupted) selfInterrupt(); throw t; &#125;&#125; 2.CountDownLatch倒数，Latch是门栓的意思(倒数的一个门栓，5、4、3、2、1数到了，我这个门栓就开 了)刚前面的递增方法，用的休眠主线程等计算线程完成后，再打印结果，这并不好，我们用CountDownLatch 改造下： 1234567891011121314151617181920212223242526272829303132public class Incrementer &#123; static Long counter1 = Long.valueOf(0); static CountDownLatch latch = new CountDownLatch(10000); public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 100; j++) &#123; synchronized (Incrementer.class) &#123; //去掉锁之后结果就有问题 counter1++; latch.countDown(); &#125; try &#123; TimeUnit.MILLISECONDS.sleep(10); //添加休眠，方便对比结果。 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; System.out.println(\"创建线程完成,等待结果。\"); try &#123; latch.await(); //这里会阻塞住，等latch 倒数到0的时候，才会继续执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(counter1); &#125;&#125; 3. CyclicBarrier循环栅栏，这有一个栅栏，什么时候人满了就把栅栏推倒， 哗啦哗啦的都放出去，出去之后扎栅栏又重新起来，再来人，满了，推倒之后又继续。 123456789101112131415161718192021222324252627282930public class BusDispatcher &#123; static CountDownLatch latch = new CountDownLatch(100); static volatile int num = 0; static CyclicBarrier barrier = new CyclicBarrier(10, ()-&gt;&#123; System.out.println(Thread.currentThread().getName()+\" - 人满了发车。。。。。\"); &#125;); public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; new Thread(()-&gt;&#123; try &#123; System.out.println(\"第\"+(++num)+\"个人上车\"); latch.countDown(); barrier.await(); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e)&#123; e.printStackTrace(); &#125; &#125;).start(); &#125; try &#123; latch.await(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(\"人车调度任务完成。\"); &#125;&#125; 4. PhaserPhaser它就更像是结合了CountDownLatch和CyclicBarrier，翻译一下叫阶段。Phaser是按照不同的阶段来对线程进行执行，就是它本身是维护着一个阶段这样的一个成员变量，当前 我是执行到那个阶段，是第0个，还是第1个阶段啊等等，每个阶段不同的时候这个线程都可以往前走， 有的线程走到某个阶段就停了，有的线程一直会走到结束。你的程序中如果说用到分好几个阶段执行 ， 而且有的人必须得几个人共同参与的一种情形的情况下可能会用到这个Phaser。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class PhaserTest &#123; static GamePhaser phaser = new GamePhaser(3); public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; sleepSeconds(1); System.out.println(Thread.currentThread().getName()+\" 到\"); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"玩第一个游戏。。。\"); sleepSeconds(2); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"玩第二个游戏。。。\"); sleepSeconds(3); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"玩第三个游戏。。。\"); sleepSeconds(4); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"玩第四个游戏。。。\"); sleepSeconds(5); phaser.arriveAndAwaitAdvance(); System.out.println(Thread.currentThread().getName()+\"准备离开。。。\"); sleepSeconds(2); phaser.arriveAndAwaitAdvance(); &#125;,\"00\"+(i+1)).start(); &#125; &#125; private static void sleepSeconds(int seconds) &#123; try &#123; TimeUnit.SECONDS.sleep(seconds); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class GamePhaser extends Phaser &#123; public GamePhaser(int parties) &#123; super(parties); &#125; /** * @param phase 第几个阶段， * @param registeredParties 当前有多少线程参与 * @return if this phaser should terminate, 是否要结束phaser */ @Override protected boolean onAdvance(int phase, int registeredParties) &#123; switch (phase) &#123; case 0: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"人到齐了开始玩第一个游戏^-^\"); System.out.println(\"\"); return false; case 1: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"开始玩第二个游戏^-^\"); System.out.println(\"\"); return false; case 2: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"开始玩第三个游戏^-^\"); System.out.println(\"\"); return false; case 3: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"开始玩第四个游戏^-^\"); System.out.println(\"\"); return false; case 4: System.out.println(\"registeredParties:\" + registeredParties); System.out.println(\"完成第\" + phase + \"阶段， 当前时间(秒)\" + System.currentTimeMillis() / 1000); System.out.println(\"游戏结束了，谢谢参与 ^-^\"); System.out.println(\"\"); return true; default: return true; &#125; &#125; &#125;&#125; 5. ReadWriteLock这个ReadWriteLock 是读写锁。读写锁的概念其实就是共享锁和排他锁，读锁就是共享锁，写锁就是排他锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ReadWriteLockTest &#123; static ReadWriteLock readWriteLock = new ReentrantReadWriteLock(); static Lock readLock = readWriteLock.readLock(); static Lock writeLock = readWriteLock.writeLock(); static int value = 0; public static void main(String[] arges)&#123; for (int i = 0; i &lt; 10; i++) &#123; //读线程不用阻塞，可以并发完成工作 new Thread(()-&gt;&#123; readLock.lock(); try &#123; ReadWriteLockTest.read(); &#125; finally &#123; //记得Reentrant readLock.unlock(); &#125; &#125;).start(); &#125; //写线程会阻塞，需要排序完成任务 for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; writeLock.lock(); try &#123; ReadWriteLockTest.write(1); &#125; finally &#123; writeLock.unlock(); &#125; &#125;).start(); &#125; &#125; public static void read()&#123; try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(\"read value =\" + value); &#125; public static void write(int num)&#123; try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; value += num; System.out.println(\"write value =\" + value); &#125;&#125; 6. SemaphoreSemaphore 含义就是限流，比如说流水线人不能全去上洗手间吧，所以得限制，每个上洗手间的人必须要领到洗手卡才能去，没有卡的人得等着前面的人回来，并归还了卡。默认Semaphore是非公平的，new Semaphore(2, true)第二个值传true才是设置公平 1234567891011121314151617181920212223242526272829public class SemaphoreTest &#123; //定义限制数量 static Semaphore semaphore = new Semaphore(2, true); public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; try &#123; System.out.println(Thread.currentThread().getName()+\"想上厕所,排队领洗手卡。。。\"); semaphore.acquire(1); System.out.println(\"时间（秒）:\"+System.currentTimeMillis()/1000+\"，\"+Thread.currentThread().getName()+\"等到洗手卡了，上厕所ing。。。\"); TimeUnit.SECONDS.sleep(4); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; finally &#123; //用完了一定要记得归还release, 不然后边的人就没得用了。 semaphore.release(1); &#125; &#125;,\"姓名\"+(1+i)).start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 7. Exchanger交换器，俩人之间互相交换个数据用的，这里收到的消息得是成对的，否则 Exchanger 一直在等待有人来交换。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ExchangerTest &#123; static Exchanger&lt;String&gt; exchanger = new Exchanger&lt;String&gt;(); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; String contents = exchanger.exchange(Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + \" 收到消息：\" + contents); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"thread 001\").start(); new Thread(() -&gt; &#123; try &#123; String contents = exchanger.exchange(Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + \" 收到消息：\" + contents); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"thread 002\").start(); new Thread(() -&gt; &#123; try &#123; String contents = exchanger.exchange(Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + \" 收到消息：\" + contents); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"thread 003\").start(); new Thread(() -&gt; &#123; try &#123; String contents = exchanger.exchange(Thread.currentThread().getName()); System.out.println(Thread.currentThread().getName() + \" 收到消息：\" + contents); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"thread 004\").start(); &#125;&#125; 十、LockSuport*在JDK1.6中的java.util.concurrent的子包locks中引了LockSupport这个API，LockSupport是一个比较底层的工具类，用来创建锁和其他同步工具类的基本线程阻塞原语。java锁和同步器框架的核心 AQS: AbstractQueuedSynchronizer，就是通过调用 LockSupport.park()和 LockSupport.unpark()的方法，来实现线程的阻塞和唤醒的。 LockSuport的几个特点 LockSupport不需要synchornized加锁就可以实现线程的阻塞和唤醒 LockSupport.unpartk()可以先于LockSupport.park()执行，并且线程不会阻塞 如果一个线程处于等待状态，连续调用了两次park()方法，就会使该线程永远无法被唤醒 park()和unpark()方法的实现是由Unsefa类提供的，而Unsefa类是由C和C++语言完成的，它主要通过一个变量作为一个标识，变量值在0，1之间来回切换，当这个变量大于0的时候线程就获得了“令牌”，其实park()和unpark()方法就是在改变这个变量的值，来达到线程的阻塞和唤醒的1234567891011121314151617181920212223242526272829303132333435363738394041// LockSuport 要求用线程顺序打印A1B2C3....Z26public class PrintFactory &#123; static char[] letters = &#123;'a', 'b', 'c', 'd', 'e', 'f', 'g'&#125;; static int[] nums = &#123;1, 2, 3, 4, 5, 6, 7&#125;; static Thread letterPrinter = new Thread(LetterThread::print); static Thread numPrinter = new Thread(NumThread::print); public static void main(String[] args) &#123; letterPrinter.start(); numPrinter.start(); &#125; static class LetterThread &#123; public static void print() &#123; for (int i = 0; i &lt; letters.length; i++) &#123; System.out.print(letters[i]); LockSupport.unpark(numPrinter); if(i &lt; letters.length -1)&#123; LockSupport.park(); &#125; &#125; &#125; &#125; static class NumThread &#123; public static void print() &#123; LockSupport.park(); for (int i = 0; i &lt; nums.length; i++) &#123; System.out.print(nums[i]); LockSupport.unpark(letterPrinter); if(i &lt; letters.length -1)&#123; LockSupport.park(); &#125; &#125; &#125; &#125;&#125; 十一、Java的四种引用 强、软、弱、虚 比如Object o = new Object()，这就是普通的引用，也就是强引用，只要有一个应用指向这个对象，那么垃圾回收器一定不会回收它。 软引用 SoftReference&lt;byte[]&gt; m = new SoftReference&lt;&gt;(new byte[1024102410])当有一个对象(字节数组)被一个软引用所指向的时候，只有系统内存不够 用的时候，才会回收它(字节数组) 弱引用 WeakReference m = new WeakReference&lt;&gt;(new M())只要遭遇到gc就会回收 虚引用 PhantomReference phantomReference = new PhantomReference&lt;&gt;(new M(), QUEUE);对于虚引用它就干一件事，它就是管理堆外内存的，首先第一点，这个虚引用的构造方法至少都是两个参数的，第二个参数还必须是一个队列，这个虚引用基本没用，就是说不是给你用的，那么它是给谁用的呢?是给写JVM(虚拟机)的人用的 十二、JMHJMH -java Microbenchmark Harness微基准测试，它是测的某一个方法的性能。支持命令行或IDEA开发工具运行，idea运行需要添加插件。直接在Idea插件查找JMH安装。安装好后就可以像Junit一样写测试。官网 http://openjdk.java.net/projects/code-tools/jmh/Maven 引用： 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-core&lt;/artifactId&gt; &lt;version&gt;1.21&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess --&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt; &lt;version&gt;1.21&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 使用示例,代码写在test目录下，类似junit测试： 12345678@Benchmark@Warmup(iteration&#x3D;1, time&#x3D;3) &#x2F;&#x2F;在专业测试里面首先要进行预热，预热多少次，预热多少时间@Fork(5) &#x2F;&#x2F;用多少个线程去执行我们的程序 @BenchmarkMode(Mode.Throughput) &#x2F;&#x2F;是对基准测试的一个模式，这个模式用的最多的是 Throughput吞吐量@Measurement(iteration&#x3D;1, time&#x3D;3) &#x2F;&#x2F;是整个测试要测试多少遍，调用这个方法要调用多少次public void test() &#123; &#x2F;&#x2F;.... 调用测试方法&#125; 十三、Disrupter主页：http://lmax-exchange.github.io/disruptor/ 源码：https://github.com/LMAX-Exchange/disruptor GettingStarted: https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started api: http://lmax-exchange.github.io/disruptor/docs/index.html maven: https://mvnrepository.com/artifact/com.lmax/disruptor ifeve：http://ifeve.com/disruptor/ Disruptor 开源的并发框架，并获得2011 Duke’s 程序框架创新奖，能够在无锁的情况下实现网络的Queue并发操作。 如果把它用作MQ的话，单机最快的MQ，性能非常的高，主要是它里 用的全都是CAS, 另外把各种各样的性能开发到了极致。 Disruptor就是在内存里，Disruptor简单理解就是内存里用于存放元素的一个高效率的队列。 Disruptor叫无锁、高并发、环形Buffer，直接覆盖(不用清除)旧的数据，降低GC频率，用于生产者消费者模式 RingBuffer是一个环形队列，和其他队列不一样的是他是一个环形队列，环形的Buffer。一般情况下我们的容器是一个队列，不管你是用链表实现还是用数组实现的，它会是一个队列，那么这个队列生产者这边使劲往里塞，消费者这边使劲往外拿，但Disruptor的核心是一个环形的buffer。 RingBuffer的序号，指向下一个可用的元素 采用数组实现，没有首尾指针对比ConcurrentLinkedQueue，用数组实现的速度更快假如长度为8，当添加到第12个元素的时候在哪个序号上呢?用12%8决定当Buffer被填满的时候到底是覆盖还是等待，由Produce决定 长度设为2的n次幂，利于二进制计算，例如:12%8=12&amp;(8-1) 等待策略 (常用)BlockingWaitStrategy:通过线程堵塞的方式，等待生产者唤醒，被唤醒后，再循环检查依赖的sequence是否已经消费。 BusySpinWaitStrategy:线程一直自旋等待，可能比较耗cpu LiteBlockingWaitStrategy:线程阻塞等待生产者唤醒，与BlockingWaitStrategy相比，区别在 signalNeeded.getAndSet，如果两个线程同时访问一个访问waitfor，一个访问signalAll时，可以减少lock加锁次数 LiteTimeoutBlockingWaitStrategy:与LiteBlockingWaitStrategy相比，设置了阻塞时间，超过时间后抛出异常 PhasedBackoffWaitStrategy:根据时间参数和传入的等待策略来决定使用那种等待策略 TimeoutBlockingWaitStrategy:相对于BlockingWaitStrategy来说，设置了等待时间，超过后抛出异常 (常用)YieldingWaitStrategy:尝试100次，然后Thread.yield()让出cpu (常用)SleepingWaitStrategy:sleep","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Thread/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"多线程 - 线程池","slug":"ThreadPool","date":"2020-02-16T13:05:29.000Z","updated":"2020-03-02T23:44:38.589Z","comments":true,"path":"2020/02/16/ThreadPool/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/16/ThreadPool/","excerpt":"一、Executor执行者，是一个接口类，他有一个方法叫执行，那么执行的东西是 Runnable。 二、ExecutorService是从Executor继承，除了去实现Executor可以去执行一个任务之外，还完善了整个任务执行器的一个生命周期，就拿线程池来举例子，一个线程池里面一堆的线程就是一堆的工人，执行完一个任务之后我这个线程怎么结束啊；线程池定义了这样一些个方法： void shutdown();//结束 List shutdownNow();//马上结束 boolean isShutdown();//是否结束了 boolean isTerminated();//是不是整体都执行完了 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;//等着结束，等多长时间，时间到了还不结束的话他 就返回false Future submit(Callable task); Future&lt;?&gt; submit(Runnable task); List&lt;Future&gt; invokeAll(Collection&lt;? extends Callable&gt; tasks) throws InterruptedException; T invokeAny(Collection&lt;? extends Callable&gt; tasks) throws InterruptedException, ExecutionException;","text":"一、Executor执行者，是一个接口类，他有一个方法叫执行，那么执行的东西是 Runnable。 二、ExecutorService是从Executor继承，除了去实现Executor可以去执行一个任务之外，还完善了整个任务执行器的一个生命周期，就拿线程池来举例子，一个线程池里面一堆的线程就是一堆的工人，执行完一个任务之后我这个线程怎么结束啊；线程池定义了这样一些个方法： void shutdown();//结束 List shutdownNow();//马上结束 boolean isShutdown();//是否结束了 boolean isTerminated();//是不是整体都执行完了 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;//等着结束，等多长时间，时间到了还不结束的话他 就返回false Future submit(Callable task); Future&lt;?&gt; submit(Runnable task); List&lt;Future&gt; invokeAll(Collection&lt;? extends Callable&gt; tasks) throws InterruptedException; T invokeAny(Collection&lt;? extends Callable&gt; tasks) throws InterruptedException, ExecutionException; 123456789101112public class ExecutroServiceTest &#123; public static void main(String[] args) &#123; ExecutorService es = Executors.newCachedThreadPool(); FutureTask&lt;Integer&gt; task = new FutureTask(() -&gt; &#123; System.out.println(\"Executor Service Test\"); return 1; &#125;); es.execute(task); es.shutdownNow(); &#125;&#125; 他是实现了一些个线程的线程池的生命周期的东西，扩展了Executor的接口，真正的线程池的现实是在ExecutorService的这个基础上来实现的。ExecutorService的时候你会发现他除了Executor执行任务之外还有submit提交任务，执行任务是直接拿过来马上运行，而submit是扔给这个线程池，什么时候运行由这个线程池来决定，相当于 是异步的，我只要往里面一扔就不管了。那好，如果不管的话什么时候他有结果啊，这里面就涉及了比较新的类:比如说Future、RunnableFuture、FutureTask。 三、Callable以前定义一个线程的任务只能去实现Runnable接口，那在1.5之后他就增加了Callable这个接口。Callable是什么，他类似于Runnable，不过 Callable可以有返回值。 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 四、FutureFuture代表的是那个Callable被执行完了之后我怎么才能拿到那个结果啊，它会封装到一个Future里面。Future将来，未来。未来你执行完之后可以把这个结果放到这个未来有可能执行完的结果里头，所以Future代表的是未来执行完的一个结果。把Callable的任务扔给线程池，线程池异步的执行完了，就是把任务交给线程池之后，调用get方法直到有结果之后get会返回。Callable一般是配合线程池和Future来用的。 五、FutureTask其实更灵活的一个用法是FutureTask，即是一个Future同时又是一个Task，原来这Callable只能一个Task只能是一个任务但是他不能作为一个Future来用。这个FutureTask相当于是我自己可以作为一个任务来用，同时这个任务完成之后的结果也存在于这个对象里，为什么他能做到这一点，因 为FutureTask他实现了RunnableFuture，而RunnableFuture即实现了Runnable又实现了Future，所以他即是一个任务又是一个Future 12345678910public class FutrueTaskTest &#123; public static void main(String[] args) &#123; FutureTask task = new FutureTask(()-&gt;&#123; System.out.println(\"future task test\"); return 1; &#125;); new Thread(task).start(); &#125;&#125; 六、CompletableFutureCompletableFuture他的底层用的是ForkJoinPool，底层特别复杂，但是用法特别灵活。 七、目前JDK提供的有两种类型 ThreadPoolExecutor 普通的线程池 ForkJoinPool 八、ThreadPoolExecutorThreadPoolExecutor他的父类是AbstractExecutorService，AbstractExecutorService 实现了 ExecutorService，再ExecutorService的父类是Executor，所以ThreadPoolExecutor就相当于线程池的执行器 定义这一个线程池，这里面的七个参数: corePoolSoze 核心线程数，最开始的时候是有这个线程池里面是有一定的核心线程数 的; maximumPoolSize 最大线程数，线程数不够了，能扩展到最大线程是多少; keepAliveTime 生存时间，意思是这个线程有很长时间没干活了请你把它归还给操作系 TimeUnit.SECONDS 生存时间的单位到底是毫秒纳秒还是秒自己去定义; 任务队列，就是我们前面讲的BlockingQueue，各种各样的BlockingQueue都可以; 线程工厂, 要去实现ThreadFactory的接口，这个接口只有一个方法叫newThread，所以就是产生线程的，可以通过这种方式产生自定义的线程，默认产生的是defaultThreadFactory，而defaultThreadFactory 产生线程的时候有几个特点: new出来的时候指定了group制定了线程名字，然后指定的这个线程 绝对不是守护线程，设定好你线程的优先级。自己可以定义产生的到底是什么样的线程，指定线程名叫什么(为什么要指定线程名称，有什么意义，就是可以方便出错是回溯); 拒绝策略，指的是线程池忙，而且任务队列满这种情况下我们就要执行各种各样的拒绝策略，jdk默认提供了四种拒绝策略，也是可以自定义的。 1:Abort:抛异常 2:Discard:扔掉，不抛异常 3:DiscardOldest:扔掉排队时间最久的 4:CallerRuns:调用者处理服务一般情况这四种我们会自定义策略，去实现这个拒绝策略的接口，处理的方式是一般我们的消息需要保存下来，并且记录日志。 九、JDK给我们提供了一些默认的线程池的实现1. SingleThreadPool只有一个线程，这个一个线程的线程池可以保证我们扔进去的任务是顺序执行的。 12345678ExecutorService service &#x3D; Executors.newSingleThreadExecutor();public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 2. CachedThreadPoolCachedThreadPool的特点，就是你来一个任务我给你启动一个线程，当然前提是我的线程池里面有线程存在而且他还没有到达60秒钟的回收时间的时候，来一个任务，如果有线程存在我就用现有的线程，但是在有新的任务来的时候，如果其他线程忙就启动一个新的，CachedThreadPool用的任务队列是 synchronousQueue，它是一个手递手容量为空的Queue，就是你来一个东西必须得有一个线程把他拿走，不然我提交任务的线程从这阻塞住了。 123456ExecutorService executor &#x3D; Executors.newCachedThreadPool();public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 3. FixedThreadPoolFixedThreadPool指定一个参数，到底有多少个线程，你看他的核心线程和最大线程都是固定的，因为他的最大线程和核心线程都是固定的就没有回收之说，所以把keepAliveTime指定成0，这里用的是LinkedBlockingQueue 123456ExecutorService executor &#x3D; Executors.newFixedThreadPool(10);public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 4. ScheduledPool定时任务线程池，隔一段时间之后这个任务会执行。这个就是我们专门用来执行定时任务的一个线程池。看源码，我们newScheduledThreadPool的时 候他返回的是ScheduledThreadPoolExecutor，然后在ScheduledThreadPoolExecutor里面他调用了 super，他的super又是ThreadPoolExecutor，它本质上还是ThreadPoolExecutor，所以并不是别的，参数还是ThreadPool的七个参数。这是专门给定时任务用的这样的一个线程池。 1234567891011ExecutorService executor &#x3D; Executors.newScheduledThreadPool(10);public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125; 5. WorkStealingPool (它实际上是new了一个ForkJoinPool)WorkStealing指的是和原来线程池的区别每一个线程都有自己单独队列，所以任务不断往里扔的时候它会在每一个线程的队列上不断的累积，让某一个线程执行完自己的任务之后就回去另外一个线程上面偷，所以这个叫WorkStealing。 12345678ExecutorService executor &#x3D; Executors.newWorkStealingPool();public static ExecutorService newWorkStealingPool() &#123; return new ForkJoinPool (Runtime.getRuntime().availableProcessors(), ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; 6. ForkJoinPool它适合把大任务切分成一个一个的小任务去运行，小任务还是觉得比较大，再切。切完这个任务执行完了要进行一个汇总。 7. Cache vs Fixed什么时候用Cache什么时候用Fixed，你得精确的控制有多少个线程数，控制数量问题多数情况下得预估并发量。如果线程池中的数量过多，最终他们会竞争稀缺的处理器和内存资源，浪费大量的时间在上下文切换上，反之，如果线程的数目过少，正如你的应用所面临的情况，处理器的一些核可能就无法充分利用。《Java并发编程实战》作者 Brian Goetz建议，线程池大小与处理器的利用率之比可以使用公式来进行计算估算:线程池=你有多少个cpu 乘以 cpu期望利用率 乘以 (1+ W/C)。W除以C是等待时间与计算时间的比率。 十、线程池的一些5种状态 RUNNING:正常运行的; SHUTDOWN:调用了shutdown方法了进入了shutdown状态; STOP:调用了shutdownnow马上让他停止; TIDYING:调用了shutdown然后这个线程也执行完了，现在正在整理的这个过程叫TIDYING; TERMINATED:整个线程全部结束;","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Thread/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]},{"title":"Angular入门","slug":"angular入门","date":"2020-02-10T14:09:42.000Z","updated":"2020-02-11T00:35:49.028Z","comments":true,"path":"2020/02/10/angular入门/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/10/angular%E5%85%A5%E9%97%A8/","excerpt":"Angular 环境搭建1、安装前准备工作： 1.1、安装nodejs 安装nodejs的计算机上面必须安装nodejs, 建议安装最新稳定版本 $ node -v 1.2、安装cnpm npm可能安装包会失败，建议先用npm安装一下cnpm用淘宝镜像安装 $ npm install -g cnpm –registry=https://registry.npm.taobao.org 2、使用 npm/cnpm 命令安装 angular/cli (只需要安装一次) $ npm install -g @angular/cli 或者 cnpm install -g @angular/cli","text":"Angular 环境搭建1、安装前准备工作： 1.1、安装nodejs 安装nodejs的计算机上面必须安装nodejs, 建议安装最新稳定版本 $ node -v 1.2、安装cnpm npm可能安装包会失败，建议先用npm安装一下cnpm用淘宝镜像安装 $ npm install -g cnpm –registry=https://registry.npm.taobao.org 2、使用 npm/cnpm 命令安装 angular/cli (只需要安装一次) $ npm install -g @angular/cli 或者 cnpm install -g @angular/cli Angular 创建项目1、打开命令行工具找到你要创建项目的目录2、创建项目 ng new 项目名称 直接安装: $ ng new angulardemo 如果要跳过npm i 安装: $ ng new angulardemo –skip-install 再手动用cnpm install 代替npm i安装 $ cd angulardemo $ cnpm install3、运行项目 $ ng serve –open 访问：http://localhost:4200","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://github.com/casparthh/casparthh.github.io/tags/Angular/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"algorithm","slug":"algorithm","date":"2020-02-09T10:21:47.000Z","updated":"2020-02-24T02:05:35.578Z","comments":true,"path":"2020/02/09/algorithm/","link":"","permalink":"https://github.com/casparthh/casparthh.github.io/2020/02/09/algorithm/","excerpt":"常见排序列表","text":"常见排序列表 选择排序选择排序是给定位置去找数。选择排序是按顺序比较，找最大值或者最小值，每一轮比较都只需要换一次位置； 1234567891011121314151617181920212223242526272829303132&#x2F;** * 由于每一次是前一个和后一个对比，所以循环的次数应该是 length - 1; * @param nums *&#x2F;public static void selection(int[] nums) &#123; for (int i &#x3D; 0; i &lt; nums.length - 1; i++) &#123; int minIndex &#x3D; i; for (int j &#x3D; i + 1; j &lt; nums.length; j++) &#123; minIndex &#x3D; nums[minIndex] &gt; nums[j] ? j : minIndex; &#125; swap(nums, i, minIndex); &#125;&#125;&#x2F;** * 选择排序优化版，每次外层循环找出最小值和最大值，分别放到数组的前后，减少外层循环 * @param nums *&#x2F;public static void selection(int[] nums) &#123; for (int i &#x3D; 0, len &#x3D; nums.length; i &lt; len; i++) &#123; int minIndex &#x3D; i &#x3D;&#x3D; 0 ? 0 : len; int maxIndex &#x3D; i &#x3D;&#x3D; 0 ? len - 1 : 0; for (int j &#x3D; i; j &lt; len; j++) &#123; minIndex &#x3D; nums[minIndex] &gt; nums[j] ? j : minIndex; maxIndex &#x3D; nums[maxIndex] &gt; nums[j] ? maxIndex : j; &#125; swap(nums, i, minIndex); maxIndex &#x3D; maxIndex &#x3D;&#x3D; i ? minIndex : maxIndex; swap(nums, maxIndex, len - 1); len--; &#125;&#125; 冒泡排序冒泡排序是通过数去找位置，比较相邻位置的两个数，每一轮比较后，位置不对都需要换位置 123456789101112131415&#x2F;** * 由于前后两位对比，所以外层循环的次数应该是 length - 1; * 内存循环次数是当前数组未排序长度 - 1 * * @param nums *&#x2F;public static void bubble(int[] nums) &#123; for (int i &#x3D; 1; i &lt; nums.length; i++) &#123; for (int j &#x3D; 0; j &lt; nums.length - i; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; swap(nums, j, j + 1); &#125; &#125; &#125;&#125; 插入排序每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。 1234567891011121314151617&#x2F;** * 插入排序 * * @param nums *&#x2F;public static void insertion(int[] nums) &#123; for (int i &#x3D; 1; i &lt; nums.length; i++) &#123; for (int j &#x3D; i; j &gt; 0; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; swap(nums, j, j - 1); &#125; else &#123; &#x2F;&#x2F;如果当前元素大于等于上一个元素了，跳出内循环。 break; &#125; &#125; &#125;&#125; 归并排序归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。分解：将列表越分越小，直至分成一个元素。终止条件：一个元素是有序的。合并：将两个有序列表归并，列表越来越大。 1234567891011121314151617181920212223242526272829303132public static void merge(int[] nums, int left, int right) &#123; if (right &#x3D;&#x3D; left) &#123; return; &#125; &#x2F;&#x2F;分两半 int mid &#x3D; (right - left) &#x2F; 2 + left; merge(nums, left, mid); merge(nums, mid + 1, right); merge(nums, left, mid + 1, right);&#125;public static void merge(int[] nums, int leftIndex, int rightIndex, int rightBound) &#123; int leftBound &#x3D; rightIndex - 1; int[] buffer &#x3D; new int[rightBound - leftIndex + 1]; int l &#x3D; leftIndex, r &#x3D; rightIndex, bufferIndex &#x3D; 0; while (l &lt;&#x3D; leftBound &amp;&amp; r &lt;&#x3D; rightBound) &#123; buffer[bufferIndex++] &#x3D; nums[l] &lt;&#x3D; nums[r] ? nums[l++] : nums[r++]; &#125; while (l &lt;&#x3D; leftBound) &#123; buffer[bufferIndex++] &#x3D; nums[l++]; &#125; while (r &lt;&#x3D; rightBound) &#123; buffer[bufferIndex++] &#x3D; nums[r++]; &#125; for (int i &#x3D; 0; i &lt; buffer.length; i++) &#123; nums[leftIndex + i] &#x3D; buffer[i]; &#125;&#125; 快速排序速排序是常用的几种排序中空间时间最优秀的排序，可以适用各种数据结构。快排的方法是先给定一个数，然后将待排序的数据分别于这个数比较，从左到右的遍历下标，比这个数大的放在右边，比这个数小的放在左边，而后分别对左边和右边的数据做递归引用排序，最终就能得到有序的数据 123456789101112131415161718192021222324public static void quick(int[] nums, int left, int rightBound) &#123; int pivot &#x3D; nums[(rightBound - left) &#x2F; 2 + left]; int l &#x3D; left; int rb &#x3D; rightBound; while (l &lt;&#x3D; rb) &#123; while (nums[l] &lt; pivot) &#123; l++; &#125; while (nums[rb] &gt; pivot) &#123; rb--; &#125; if (l &lt;&#x3D; rb) &#123; swap(nums, l, rb); l++; rb--; &#125; &#125; if (left &lt; l) &#123; quick(nums, left, rb); &#125; if (l &lt; rightBound) &#123; quick(nums, l, rightBound); &#125;&#125;","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/casparthh/casparthh.github.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://github.com/casparthh/casparthh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}]}]}